# I18N 项目设置

在上一章中，我们讲到了部署，把核心的项目骨架完成了。那么这一章我们就直接讲`18n`，很少有人直接在前面的部分讲`18n`,但我把`18n`的顺序提到前面的排序主要是出于下面的这些考虑：

1. 项目的页面索引数量翻倍，添加来自小语种的曝光。
2. 在一开始做这件事的话，不用担心后续的I18N的内容覆盖率，在后期会让这个改造工程量特别的大。
3. 整个最简AI项目，追求的是以最快的方式生成闭环项目，而I18N自带的配置化JSON结构以Key填充内容的方式，更适合AI去填充。

## I18N基础设置

那么就开始我们的项目I18N基础搭建把，这一节的版本是 [github tag v2.01](https://github.com/Shiinama/next-cloudflare-template/tree/v2.0.1)，基础部分都是看文档，所以不会过多的赘述。

### 项目基础配置

依赖下载和目录配置文档(https://next-intl.dev/docs/getting-started/app-router/with-i18n-routing) ，主要作用是，配置项目的i18n布局/页面、跳转、路由中间件、翻译文件。

`app/[locale]/about/page.tsx`是客户端组件的用法，`app/[locale]/page.tsx`是服务端路线的用法。

### Ts和Eslint设置

[项目的Typescript文档](https://next-intl.dev/docs/workflows/typescript)、[项目的Eslint文档](https://next-intl.dev/docs/workflows/linting)。主要作用是用于项目的 `Ts`语法提示以及 `Eslint` 限制必须覆盖，效果如下：

Eslint报错

![](https://ik.imagekit.io/ixou4q6nu/i18n-eslint-error.png)

Ts语法提示

![](https://ik.imagekit.io/ixou4q6nu/ts-prompt.png)

## I18N路由与检测

这一节的版本是 [github tag v2.02](https://github.com/Shiinama/next-cloudflare-template/tree/v2.0.2)。

### 处理路由前缀

在`intl`中，默认的前缀模式是`Always`，但这个行为不符合SEO的实践，需要在 `en` 语言（默认语言）时去掉路由后缀，同时保留其他语言的路由后缀。

在 next-intl 中，`localePrefix` 有几个选项：

- `always`: 总是显示语言前缀
- `never`: 从不显示语言前缀
- `as-needed`: 只为非默认语言显示前缀

将 `localePrefix` 从 `always` 改为 `as-needed`，这样默认语言 `en` 就不会显示在 URL 中，而其他语言如 `zh` 会保留前缀。

```typescript
import { defineRouting } from 'next-intl/routing'

export const routing = defineRouting({
  locales: ['en', 'zh'],
  defaultLocale: 'en',
  localePrefix: 'as-needed'
})
```

这样修改后，英文页面的 URL 将是 `/about`，中文页面的 URL 将是 `/zh/about`。

### 路由检测机制

Next-intl自己有一套检测机制，可以根据多种因素自动确定用户的首选语言。默认情况下，会按照以下优先级顺序检测语言：

1. URL 路径中的语言前缀（例如 `/zh/about`）
2. Cookie 中保存的之前检测到的语言偏好
3. 浏览器的 `accept-language` 请求头
4. 如果以上都无法匹配，则使用 `defaultLocale` 设置的默认语言

用户第一次访问网站时会根据浏览器语言自动跳转到相应语言版本，后续访问则会记住他们的语言偏好。

#### 工作流示例

1. 用户请求 `/` 路径，系统根据 `accept-language` 头部匹配到 `en` 语言
2. 用户被重定向到 `/` (因为我们设置了 `localePrefix: 'as-needed'` 且 `en` 是默认语言)
3. 应用渲染 `<Link locale="zh" href="/">切换到中文</Link>` 允许用户切换到中文
4. 用户点击链接后，发起对 `/zh` 的请求
5. 中间件会添加一个 cookie 来记住用户对中文的偏好
6. 用户稍后再次请求 `/`，中间件会根据 cookie 重定向到 `/zh`

#### 语言匹配算法

Next-intl 使用 `@formatjs/intl-localematcher` 的"最佳匹配"算法来确定最合适的语言。

简单来说，这个算法能更智能地理解用户想要的语言，即使没有完全匹配的选项。

例如，如果您的应用支持 `en` 和 `zh` 这两种语言，而用户浏览器发送的 `accept-language` 头是 `en-GB`：

- "查找"算法会逐步移除用户 `accept-language` 头中的子标签，直到找到匹配项。在这种情况下，它找不到匹配项，因此会使用默认语言。
- "最佳匹配"算法会比较用户的 `accept-language` 头与可用语言之间的距离，同时考虑区域信息。因此，"最佳匹配"算法能够将 `en` 匹配为最佳匹配语言。

想象一下这个场景：你的网站支持英语(`en`)和简体中文(`zh`)，英国的用户访问你的网站，他的浏览器设置为英式英语(`en-GB`)，传统的"查找"算法会说："我找不到英式英语，所以我将使用默认语言"。而"最佳匹配"算法会说："虽然没有英式英语，但英语和英式英语很接近，所以我会选择英语而不是默认的中文"。

## 常用语言代码最佳实践

当我们理解了语言匹配后，我写了一个常用语言最佳实践配置示例：

```typescript
import { defineRouting } from 'next-intl/routing'

export const locales = [
  {
    code: 'en',
    name: 'English',
    dir: 'ltr'
  },
  {
    code: 'zh',
    name: '中文',
    dir: 'ltr'
  },
  {
    code: 'ja',
    name: '日本語',
    dir: 'ltr'
  },
  {
    code: 'ko',
    name: '한국어',
    dir: 'ltr'
  },
  {
    code: 'es',
    name: 'Español',
    dir: 'ltr'
  },
  {
    code: 'fr',
    name: 'Français',
    dir: 'ltr'
  },
  {
    code: 'de',
    name: 'Deutsch',
    dir: 'ltr'
  },
  {
    code: 'it',
    name: 'Italiano',
    dir: 'ltr'
  },
  {
    code: 'ru',
    name: 'Русский',
    dir: 'ltr'
  },
  {
    code: 'pt',
    name: 'Português',
    dir: 'ltr'
  },
  {
    code: 'ar',
    name: 'العربية',
    dir: 'rtl'
  },
  {
    code: 'hi',
    name: 'हिन्दी',
    dir: 'ltr'
  }
]

export const routing = defineRouting({
  locales: locales.map((i) => i.code),
  defaultLocale: 'en',
  localePrefix: 'as-needed'
})
```

- `code`: 使用简写的语言代码
- `name`: 该语言的本地名称显示，用于后续切换语言的展示
- `dir`: 文本方向，`ltr`（从左到右）或`rtl`（从右到左，如阿拉伯语）

这样，我们的翻译文件也应该使用相应的简写命名（下一节就开始AI自动填值和创建文件）：

```
/messages
  /en.json
  /zh.json
  /ja.json
  ...
```

而在`layout`下我们可以完成`lang`和`dir`的设置，这样设置主要是搜索引擎正确识别页面语言，并且对于阿拉伯等语言从右到左的适配。

```typescript
export default async function RootLayout({
  children,
  params
}: {
  children: React.ReactNode
  params: Promise<{ locale: string }>
}) {
  const { locale } = await params
  if (!hasLocale(routing.locales, locale)) {
    notFound()
  }
  const currentLocale = locales.find((l) => l.code === locale)

  return (
    <html lang={currentLocale?.code ?? 'en'} dir={currentLocale?.dir || 'ltr'} suppressHydrationWarning>
      <body className="antialiased">
        <NextIntlClientProvider>
          <SessionProvider>
            <Header />
            <Container>{children}</Container>
            <Footer />
          </SessionProvider>
          <Toaster richColors />
        </NextIntlClientProvider>
      </body>
    </html>
  )
}

```

## 整套I18N方案的AI自动化

显然，我们需要有一套自动化方案来处理管理I18N的文案，我直接写好了。这一节的版本是 [github tag v2.1.0](https://github.com/Shiinama/next-cloudflare-template/tree/v2.1.0)。

### 核心翻译功能

我们的翻译系统由三个主要部分组成，位置在`scripts/18n`：

1. **翻译核心（translate.ts）**：负责实际的翻译逻辑和API调用
2. **命令行工具（cli.ts）**：提供友好的命令行界面来执行翻译任务
3. **工具函数（utils.ts）**：提供辅助功能如键提取、缺失键查找和对象合并

### 翻译的模式

翻译分为了三种模式：

1. **完整翻译（full）**：翻译所有键，完全替换现有翻译文件或与现有翻译合并
2. **缺失翻译（missing）**：只翻译目标语言文件中缺失的键
3. **指定键翻译（keys）**：只翻译用户指定的特定键

```typescript
switch (mode) {
  case 'full':
    sourceToTranslate = englishMessages
    break

  case 'keys':
    if (keys.length === 0) {
      throw new Error('Keys模式需要至少一个要翻译的键')
    }
    sourceToTranslate = extractKeys(englishMessages, keys)
    break

  case 'missing':
    missingKeys = findMissingKeys(englishMessages, existingTranslations)
    if (missingKeys.length === 0) {
      results.push({
        success: true,
        locale: locale.code,
        message: `${locale.name} 没有发现缺失的键`,
        translatedKeys: []
      })
      continue // 跳到下一个语言
    }
    sourceToTranslate = extractKeys(englishMessages, missingKeys)
    break
}
```

### 翻译核心实现

翻译核心使用Cloudflare AI API（直接的fetch api不用处理依赖和类型问题）来翻译，主要是免费且模型又不算太差：

核心翻译流程如下：

1. 读取英文（源语言）消息文件
2. 根据选择的模式确定需要翻译的内容
3. 为每种目标语言构建专门的翻译提示
4. 调用AI API进行翻译
5. 解析返回的JSON并与现有翻译合并（如果需要）
6. 将结果写入对应的语言文件

```typescript
// 翻译提示词
const prompt = `
I need to translate a JSON structure from English to ${locale.name}.

Let me approach this step by step:

1. First, I'll carefully read and understand the entire JSON structure.
2. I'll identify all the text values that need translation, leaving the keys unchanged.
3. For each value, I'll translate it from English to ${locale.name} while preserving:
   - Any placeholders like {name}, {count}, etc.
   - Any formatting or special characters
   - The original meaning and context
4. I'll maintain the exact same JSON structure and nesting
5. I'll verify that my output is valid JSON with properly escaped characters

Here's the JSON to translate:
${JSON.stringify(sourceToTranslate, null, 2)}

I'll respond with only the translated JSON, without any additional text, explanations, or formatting.
`
```

- 保留所有JSON键不变
- 只翻译值部分
- 保留所有占位符（如`{name}`）
- 维持原始JSON结构
- 返回有效的JSON格式

### 命令行工具

为了方便使用，我写了一个命令行工具，支持以下选项：

- `--mode, -m`：翻译模式（full、missing或keys）
- `--locales, -l`：目标语言（逗号分隔）
- `--keys, -k`：要翻译的键（逗号分隔，使用点表示法表示嵌套键）
- `--force, -f`：强制覆盖现有翻译
- `--list-locales`：列出所有可用语言

大致可以有这些基本用法：

```sh
# 列出所有支持的语言
pnpm i18n:translate --list-locales

# 翻译缺失的键（增量翻译）
pnpm i18n:translate --mode missing

# 翻译特定键
pnpm i18n:translate --mode keys --keys "HomePage.title,AboutPage.description"

# 翻译到特定语言
pnpm i18n:translate --mode missing --locales "zh,ja"

# 完整翻译
pnpm i18n:translate --mode full --force
```

在json中也添加了简便的写法

```json
"i18n:translate": "tsx scripts/18n/cli.ts",
"i18n:full": "tsx scripts/18n/cli.ts --mode=full",
"i18n:missing": "tsx scripts/18n/cli.ts --mode=missing",
"i18n:keys": "tsx scripts/18n/cli.ts --mode=keys --keys"
```

> 大家可以自由去组合这个i18n的脚本，达成不一样的效果。

### 我自己最常的工作流用法

#### 开发部署流

先在`en`里面写完保证英文的正确性，然后直接跑`pnpm i18n:translate`把所有的i18n文件生成一遍。

但如果英文本身不好怎么办那？将下面代码部分中的`en`换成`zh`，工作流就是先写`zh`。

```typescript
// 读取英文消息文件作为源
const messagesDir = path.join(process.cwd(), 'messages')
const englishMessagesPath = path.join(messagesDir, 'en.json')
const englishMessagesText = await fs.readFile(englishMessagesPath, 'utf-8')
const englishMessages = JSON.parse(englishMessagesText)

// 确定要翻译的语言
const localesToTranslate = targetLocales
  ? locales.filter((l) => targetLocales.includes(l.code) && l.code !== 'en')
  : locales.filter((l) => l.code !== 'en')
```

#### 替换流

适用于某个key或者一堆key写得不好，要修改替换，还是先把`en`里面的改了，然后执行`pnpm i18n:keys "HomePage.title"`(类似命令，可以以，拼接多个key)，会将翻译进行覆盖式生成。

### Issue

在代码的翻译部分，我留下了一个根本性思路上的设计问题，以及一些小的问题看看大家能不能找到。

## 结束

本节结束，在下一节也是继续讲I18N，会修复本节留下的根本性设计问题，以及完成I18N的SEO部分。

> 本节的完成版`I18N`的版本号是[github tag v2.1.6](https://github.com/Shiinama/next-cloudflare-template/tree/v2.1.6)。
