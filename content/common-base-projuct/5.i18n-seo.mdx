# I18nå®Œå–„ä¸SEO

åœ¨ä¸Šç« ä¸­ï¼Œæˆ‘ä»¬è®²äº†ä¸€ä¸‹I18nçš„ä¸€äº›é…ç½®ã€‚é‚£ä¹ˆè¿™ä¸€ç« ï¼Œæˆ‘ä»¬éœ€è¦ç»§ç»­å®Œå–„I18nçš„è‡ªåŠ¨åŒ–è„šæœ¬ï¼Œä»¥åŠå®ŒæˆI18nçš„SEOé…ç½®ã€‚

## è‡ªåŠ¨åŒ–ç¿»è¯‘çš„é—®é¢˜

é‚£æˆ‘ä»¬å…ˆæ¥è®²è®²é—®é¢˜å§ã€‚è¿™ä¸€èŠ‚çš„ç‰ˆæœ¬æ˜¯ [github tag v2.2.1](https://github.com/Shiinama/next-cloudflare-template/tree/v2.2.1)ã€‚

### fullæ¨¡å¼

é¦–å…ˆé—®é¢˜æœ€å¤§çš„æ˜¯`full`æ¨¡å¼ï¼Œä¹Ÿè®¸å®ƒä¸åº”è¯¥å«`full`ï¼Œåº”è¯¥å«`reset`, å› ä¸º `missing` æ¨¡å¼å·²ç»èƒ½å¤Ÿé«˜æ•ˆåœ°å¤„ç†å¢é‡ç¿»è¯‘éœ€æ±‚ã€‚ä¿ç•™ `full` æ¨¡å¼çš„å”¯ä¸€ç†ç”±æ˜¯åœ¨éœ€è¦å®Œå…¨é‡ç½®ç¿»è¯‘æ—¶ä½¿ç”¨ï¼Œè¿™ç§æƒ…å†µåº”è¯¥å¾ˆå°‘è§ï¼Œä¸”è¦é¿å…ä½¿ç”¨ï¼Œå› ä¸ºåœ¨åæœŸè¿™æ ·åšæ‰€éœ€çš„ä¸Šä¸‹æ–‡å®åœ¨æ˜¯å¤ªå¤§äº†ï¼Œå¹¶ä¸”æœ‰é£é™©ã€‚

ä½†æœ€ç°å®çš„é—®é¢˜æ˜¯AIè¾“å‡ºè¿™ä¹ˆå¤šçš„å…¨é‡å†…å®¹ï¼Œæ ¹æœ¬æ— æ³•ä½¿ç”¨JSON.parseå»è½¬æˆJsonï¼Œå†…å®¹è¶Šå¤šï¼Œè¦è¾“å‡ºå›ºå®šæ ¼å¼åŒ–çš„å†…å®¹å°±è¶Šéš¾ï¼Œå› æ­¤æˆ‘ç›´æ¥æŠŠ`full`æ¨¡å¼å»æ‰äº†ï¼Œé»˜è®¤å°±æ˜¯ `missing`æ¨¡å¼ã€‚

```json
"i18n:translate": "tsx scripts/18n/cli.ts --mode=missing",
"i18n:keys": "tsx scripts/18n/cli.ts --mode=keys --keys",
"i18n:list": "tsx scripts/18n/cli.ts --list-locales"
```

### missingæ¨¡å¼çš„tokenæ¶ˆè€—

åœ¨ä½¿ç”¨ AI æ¨¡å‹è¿›è¡Œç¿»è¯‘æ—¶ï¼Œæ¯ä¸ªè¯·æ±‚éƒ½ä¼šæ¶ˆè€— tokenã€‚Token æ˜¯æ–‡æœ¬çš„åŸºæœ¬å•ä½ï¼Œé€šå¸¸ä¸€ä¸ªå•è¯ä¼šè¢«åˆ†è§£ä¸ºä¸€ä¸ªæˆ–å¤šä¸ª tokenã€‚

å½“å‰çš„ç¿»è¯‘å®ç°å­˜åœ¨ä¸¥é‡çš„ token æ¶ˆè€—é—®é¢˜ï¼Œä¸»è¦ä½“ç°åœ¨ï¼š

1.  é‡å¤çš„æç¤ºæ¨¡æ¿ï¼šå¯¹æ¯ç§è¯­è¨€éƒ½ä½¿ç”¨ç›¸åŒçš„å†—é•¿æç¤º
2.  å•è¯­è¨€å•æ¬¡è¯·æ±‚ï¼šæ¯ç§è¯­è¨€å•ç‹¬å‘é€ä¸€ä¸ªè¯·æ±‚ï¼Œæ— æ³•å…±äº«ä¸Šä¸‹æ–‡
3.  å¤šæ¬¡ API è°ƒç”¨ï¼šæ¯ä¸ªè¯­è¨€ä¸€æ¬¡ API è°ƒç”¨ï¼Œå¢åŠ äº†å»¶è¿Ÿå’Œæˆæœ¬

è§£æ³•æ˜¯ä½¿ç”¨æ‰€æœ‰è¯­è¨€ç¼ºå¤±é”®çš„å¹¶é›†ä½œä¸ºæºæ–‡æœ¬è¿›è¡Œç¿»è¯‘ï¼š

1. **æ‰¹é‡å¤„ç†ç¿»è¯‘è¯·æ±‚**ï¼šé€šè¿‡å°†æ‰€æœ‰è¯­è¨€çš„ç¼ºå¤±é”®åˆå¹¶ä¸ºä¸€ä¸ªé›†åˆï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸€æ¬¡APIè°ƒç”¨ä¸­è¯·æ±‚å¤šç§è¯­è¨€çš„ç¿»è¯‘ï¼Œè€Œä¸æ˜¯ä¸ºæ¯ç§è¯­è¨€å•ç‹¬å‘é€è¯·æ±‚ã€‚

2. **å‡å°‘é‡å¤å†…å®¹**ï¼šå½“å¤šç§è¯­è¨€éƒ½ç¼ºå°‘ç›¸åŒçš„é”®æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¿™äº›é”®çš„è‹±æ–‡åŸæ–‡å‘é€ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯æ¯ç§è¯­è¨€éƒ½é‡å¤å‘é€ã€‚

3. **å…±äº«ä¸Šä¸‹æ–‡**ï¼šAIæ¨¡å‹å¯ä»¥åœ¨ä¸€æ¬¡è¯·æ±‚ä¸­ç†è§£æ‰€æœ‰éœ€è¦ç¿»è¯‘çš„å†…å®¹ï¼Œè¿™æœ‰åŠ©äºä¿æŒç¿»è¯‘çš„ä¸€è‡´æ€§ï¼Œç‰¹åˆ«æ˜¯å¯¹äºç›¸å…³æœ¯è¯­ã€‚

4. **é™ä½APIè°ƒç”¨æˆæœ¬**ï¼šå‡å°‘APIè°ƒç”¨æ¬¡æ•°ä¸ä»…é™ä½äº†å»¶è¿Ÿï¼Œè¿˜æ˜¾è‘—å‡å°‘äº†tokenæ¶ˆè€—ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å†éœ€è¦ä¸ºæ¯ç§è¯­è¨€é‡å¤å‘é€ç›¸åŒçš„æç¤ºæ¨¡æ¿ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸‰ç§è¯­è¨€ï¼ˆä¸­æ–‡ã€æ—¥è¯­å’ŒéŸ©è¯­ï¼‰ï¼Œæ¯ç§è¯­è¨€éƒ½ç¼ºå°‘5ä¸ªç›¸åŒçš„é”®ã€‚ä½¿ç”¨æ—§æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦å‘é€3ä¸ªç‹¬ç«‹è¯·æ±‚ï¼Œæ¯ä¸ªè¯·æ±‚éƒ½åŒ…å«å®Œæ•´çš„æç¤ºæ¨¡æ¿å’Œ5ä¸ªé”®çš„å†…å®¹ã€‚è€Œä½¿ç”¨æ–°æ–¹æ³•ï¼Œæˆ‘ä»¬åªéœ€å‘é€1ä¸ªè¯·æ±‚ï¼ŒåŒ…å«ä¸€æ¬¡æç¤ºæ¨¡æ¿å’Œ5ä¸ªé”®çš„å†…å®¹ï¼Œç„¶åè¯·æ±‚AIæ¨¡å‹åŒæ—¶ç”Ÿæˆæ‰€æœ‰ä¸‰ç§è¯­è¨€çš„ç¿»è¯‘ã€‚

> é‚£æœ‰æ²¡æœ‰æ›´å¥½çš„åšæ³•é‚£ï¼Ÿæ˜¾ç„¶æœ‰çš„ï¼Œå°±æ˜¯æ·»åŠ ä¸€å¼ key + è¯­è¨€çš„å¯¹ç…§è¡¨ï¼Œä¸€ä¸ªkeyå¯¹åº”æ‰€æœ‰è¯­è¨€çš„ç¿»è¯‘ï¼Œæ¯æ¬¡ä»¥keyè·Ÿen.jsonè¿›è¡Œå¯¹ç…§ï¼Œå§‹ç»ˆä»¥å¯¹ç…§è¡¨ä¸ºä¸»ï¼Œåˆ é™¤å¯¹ç…§è¡¨çš„ä¸€è¡Œï¼Œå°±åˆ é™¤æ‰€æœ‰keyçš„ä¸€è¡Œï¼Œå¯¹ç…§è¡¨çš„ä¸€è¡Œä¸­æœ‰ä»»æ„ä¸€åˆ—ä¸ºç©ºï¼Œå°±é‡æ–°ä»¥AIç”Ÿæˆã€‚ç°åœ¨æˆ‘çš„ä¸»é¡¹ç›®å°±æ˜¯è¿™ä¹ˆåšçš„ï¼Œå‰åç«¯+æœ¬åœŸçš„å°ä¼™ä¼´ä¸€èµ·å»è¿è¥è¿™å¼ key+è¯­è¨€çš„å¯¹ç…§è¡¨ã€‚ä½†è¿™å¥—æ–¹æ¡ˆæ˜¯å¤ªå¤æ‚äº†ï¼Œä¸é€‚åˆå•äººå¼€å‘ã€‚

#### ä¼˜åŒ–åçš„ç¿»è¯‘æµç¨‹

1. æ”¶é›†æ‰€æœ‰ç›®æ ‡è¯­è¨€çš„ç¼ºå¤±é”®
2. è®¡ç®—æ‰€æœ‰ç¼ºå¤±é”®çš„å¹¶é›†
3. ä»è‹±æ–‡æ¶ˆæ¯ä¸­æå–è¿™äº›é”®çš„å€¼
4. æ„å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰ç¼ºå¤±é”®å’Œç›®æ ‡è¯­è¨€çš„å•ä¸€è¯·æ±‚
5. å‘é€è¯·æ±‚åˆ°AIæ¨¡å‹ï¼Œè·å–æ‰€æœ‰è¯­è¨€çš„ç¿»è¯‘ç»“æœ
6. è§£æç»“æœå¹¶æ›´æ–°å„è¯­è¨€çš„ç¿»è¯‘æ–‡ä»¶

è¿™ç§æ–¹æ³•ä¸ä»…æé«˜äº†æ•ˆç‡ï¼Œè¿˜å¤§å¤§é™ä½äº†APIè°ƒç”¨çš„æˆæœ¬ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†å¤šè¯­è¨€é¡¹ç›®æ—¶ã€‚ä¸»è¦çš„æ ¸å¿ƒæ”¹åŠ¨ä»£ç ï¼š

```typescript
 case 'missing':
        // æ”¶é›†æ‰€æœ‰è¯­è¨€çš„ç¼ºå¤±é”®
    for (const locale of localesToTranslate) {
      let existingTranslations = {}
      const localeFilePath = path.join(messagesDir, `${locale.code}.json`)

      try {
        const existingContent = await fs.readFile(localeFilePath, 'utf-8')
        existingTranslations = JSON.parse(existingContent)
      } catch (err) {
        console.log(`æœªæ‰¾åˆ° ${locale.code} çš„ç°æœ‰ç¿»è¯‘ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶ã€‚`)
      }

      const missingKeys = findMissingKeys(englishMessages, existingTranslations)
      if (missingKeys.length > 0) {
        missingKeysByLocale[locale.code] = missingKeys
      }
    }

    // å¦‚æœæ‰€æœ‰è¯­è¨€éƒ½æ²¡æœ‰ç¼ºå¤±é”®ï¼Œåˆ™æå‰è¿”å›
    if (Object.keys(missingKeysByLocale).length === 0) {
      return localesToTranslate.map((locale) => ({
        success: true,
        locale: locale.code,
        message: `${locale.name} æ²¡æœ‰å‘ç°ç¼ºå¤±çš„é”®`,
        translatedKeys: []
      }))
    }

    // ä½¿ç”¨æ‰€æœ‰ç¼ºå¤±é”®çš„å¹¶é›†ä½œä¸ºæº
    const allMissingKeys = [...new Set(Object.values(missingKeysByLocale).flat())]
    sourceToTranslate = extractKeys(englishMessages, allMissingKeys)
    break
```

> åœ¨å½“å‰çš„é¡¹ç›®ä¸­ï¼Œä¸è¦å†™å¤§é‡çš„ç¿»è¯‘æ–‡æ¡ˆåï¼Œå†å»è·‘`pnpm i18n:translate`ï¼Œå¦‚æœé‡è§äº†å¤§é‡ç¿»è¯‘ä¸èƒ½ä¿æŒJSONç»“æ„çš„æƒ…å†µï¼Œå¯ä»¥é‡‡ç”¨åˆ†æ‰¹è·‘çš„æ–¹å¼ã€‚

### ä¸éœ€è¦ç¿»è¯‘çš„Key

æ˜¾ç„¶æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªä¸éœ€è¦ç¿»è¯‘çš„Keyåˆ—è¡¨ï¼Œå› ä¸ºç±»ä¼¼å“ç‰Œåã€å…¬å¸ä¿¡æ¯ç­‰å€¼å…¶å®æ˜¯ä¸éœ€è¦ç¿»è¯‘çš„ï¼Œåªéœ€è¦æŠŠ`en`çš„å€¼å¡«å…¥åˆ°å…¶ä»–çš„jsonç¿»è¯‘æ–‡ä»¶ä¸­ã€‚

### ä¸Šä¸‹æ–‡é—®é¢˜

åœ¨åšAIç¿»è¯‘çš„æ—¶å€™ï¼Œæœ‰ä¸€ä¸ªæ²¡åŠæ³•é¿å…çš„é—®é¢˜ï¼Œé‚£å°±æ˜¯`max tokens`è¶…é™ï¼Œè¿™æ˜¯ä¸€æ¬¡å“åº”ä¸­æœ€å¤šå¯ä»¥ç”Ÿæˆçš„`token`é™åˆ¶ï¼Œå¤§å®¶å…¶å®å¦‚æœç»å¸¸é—®é¢˜AIé—®é¢˜ï¼Œæœ‰æ—¶å€™ä¹Ÿä¼šé‡åˆ°ï¼Œè€Œè¿™ç§é—®é¢˜åœ¨é¢ä¸´é•¿æ–‡æœ¬ç¿»è¯‘çš„æ—¶å€™æ ¼å¤–çš„æ˜æ˜¾ã€‚

è€Œè§£å†³æ–¹æ¡ˆæ˜¯é‡‡ç”¨æ‰¹å¤„ç†çš„æ–¹å¼ï¼Œæ¯ä¸€æ‰¹è®¾ç½®å‡ ä¸ª`key`ï¼Œä½¿ç”¨`key`æ¨¡å¼ï¼Œå¾ªç¯å¾€ä¸‹ï¼Œç›´åˆ°ç¿»è¯‘å®Œæˆï¼Œå¤§å®¶å¯ä»¥æ‰§è¡Œ`pnpm i18n:sequential`ã€‚

```typescript
/**
 * é¡ºåºç¿»è¯‘æ‰€æœ‰é”®
 * @param options ç¿»è¯‘é€‰é¡¹
 */
export async function sequentialTranslate(options: Omit<TranslationOptions, 'mode' | 'keys'> = {}): Promise<void> {
  try {
    // è¯»å–è‹±æ–‡æ¶ˆæ¯æ–‡ä»¶ï¼ˆä½œä¸ºåŸºå‡†ï¼‰
    const messagesDir = path.join(process.cwd(), 'messages')
    const englishMessagesPath = path.join(messagesDir, 'en.json')
    const englishMessagesText = await fs.readFile(englishMessagesPath, 'utf-8')
    const englishMessages = JSON.parse(englishMessagesText)

    // ç¡®å®šè¦ç¿»è¯‘çš„ç›®æ ‡è¯­è¨€
    const { targetLocales } = options
    const localesToTranslate = targetLocales
      ? locales.filter((l) => targetLocales.includes(l.code) && l.code !== 'en')
      : locales.filter((l) => l.code !== 'en')

    if (localesToTranslate.length === 0) {
      console.log('æ²¡æœ‰æ‰¾åˆ°è¦ç¿»è¯‘çš„ç›®æ ‡è¯­è¨€')
      return
    }

    // æå–è‹±æ–‡æ–‡ä»¶ä¸­çš„æ‰€æœ‰é”®
    const allKeys = extractAllKeys(englishMessages)
    console.log(`è‹±æ–‡æ–‡ä»¶ä¸­å…±æœ‰ ${allKeys.length} ä¸ªé”®`)

    let allMissingKeys: string[] = []

    console.log('å¼€å§‹æ£€æŸ¥å„è¯­è¨€æ–‡ä»¶ä¸­ç¼ºå¤±çš„é”®...')
    for (const locale of localesToTranslate) {
      const localeFilePath = path.join(messagesDir, `${locale.code}.json`)

      // æ£€æŸ¥ç›®æ ‡è¯­è¨€æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      let existingTranslations = {}
      let fileExists = true

      try {
        const existingContent = await fs.readFile(localeFilePath, 'utf-8')
        try {
          existingTranslations = JSON.parse(existingContent)
        } catch (parseErr) {
          console.log(`âš ï¸ ${locale.code} æ–‡ä»¶è§£æå¤±è´¥ï¼Œå°†è§†ä¸ºç©ºæ–‡ä»¶`)
          fileExists = false
        }
      } catch (err) {
        console.log(`âš ï¸ æœªæ‰¾åˆ° ${locale.code} çš„ç°æœ‰ç¿»è¯‘æ–‡ä»¶ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶`)
        fileExists = false
      }

      // ç¡®å®šç¼ºå¤±çš„é”®
      let missingKeys: string[] = []

      if (!fileExists || Object.keys(existingTranslations).length === 0) {
        // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©ºï¼Œåˆ™æ‰€æœ‰é”®éƒ½æ˜¯ç¼ºå¤±çš„
        missingKeys = [...allKeys]
        console.log(`ğŸ“ ${locale.code}: éœ€è¦ç¿»è¯‘æ‰€æœ‰ ${missingKeys.length} ä¸ªé”®`)
      } else {
        // é€’å½’æŸ¥æ‰¾ç¼ºå¤±çš„é”®
        missingKeys = findMissingOrEmptyKeys(englishMessages, existingTranslations)
        if (missingKeys.length > 0) {
          console.log(`ğŸ“ ${locale.code}: éœ€è¦ç¿»è¯‘ ${missingKeys.length} ä¸ªé”®`)
        } else {
          console.log(`âœ… ${locale.code}: å·²åŒ…å«æ‰€æœ‰é”®ï¼Œæ— éœ€ç¿»è¯‘`)
        }
      }

      // è®°å½•è¿™ä¸ªè¯­è¨€çš„ç¼ºå¤±é”®
      if (missingKeys.length > 0) {
        allMissingKeys = [...new Set([...allMissingKeys, ...missingKeys])]
      }
    }

    // å¦‚æœæ²¡æœ‰ç¼ºå¤±çš„é”®ï¼Œæå‰ç»“æŸ
    if (allMissingKeys.length === 0) {
      console.log('âœ¨ æ‰€æœ‰è¯­è¨€æ–‡ä»¶éƒ½å·²åŒ…å«æ‰€æœ‰é”®ï¼Œæ— éœ€ç¿»è¯‘')
      return
    }

    console.log(`\næ€»å…±å‘ç° ${allMissingKeys.length} ä¸ªä¸åŒçš„é”®éœ€è¦ç¿»è¯‘`)

    // è®¾ç½®æ‰¹æ¬¡å¤§å°å’Œåˆ†æ‰¹
    const batchSize = 5 // æ¯æ‰¹å¤„ç†ä¸€ä¸ªé”®ï¼Œå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´
    const batches = []

    // å°†é”®åˆ†æˆæ‰¹æ¬¡
    for (let i = 0; i < allMissingKeys.length; i += batchSize) {
      batches.push(allMissingKeys.slice(i, i + batchSize))
    }

    console.log(`å°†åˆ† ${batches.length} æ‰¹è¿›è¡Œç¿»è¯‘\n`)

    // é¡ºåºç¿»è¯‘æ¯ä¸ªæ‰¹æ¬¡
    let successCount = 0
    let failureCount = 0
    let skippedCount = 0

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i]
      console.log(`ğŸ”„ å¼€å§‹ç¿»è¯‘æ‰¹æ¬¡ ${i + 1}/${batches.length}ï¼ŒåŒ…å«é”®: ${batch.join(', ')}`)

      const translationOptions: TranslationOptions = {
        mode: 'keys',
        keys: batch,
        ...options
      }

      try {
        const results = await translateMessages(translationOptions)

        // å¤„ç†ç»“æœ
        for (const result of results) {
          if (result.success) {
            if (result.translatedKeys && result.translatedKeys.length > 0) {
              console.log(`âœ… ${result.locale}: ${result.message}`)
              successCount += result.translatedKeys.length
            } else if (result.message?.includes('æ²¡æœ‰éœ€è¦ç¿»è¯‘çš„å†…å®¹')) {
              console.log(`â„¹ï¸ ${result.locale}: ${result.message}`)
              skippedCount += batch.length
            }
          } else {
            console.log(`âŒ ${result.locale}: ${result.error}`)
            failureCount += batch.length
          }
        }
      } catch (error) {
        console.error(`âŒ æ‰¹æ¬¡ ${i + 1} ç¿»è¯‘å¤±è´¥:`, error)
        failureCount += batch.length
      }
    }

    console.log('\nâœ¨ ç¿»è¯‘å®Œæˆ!')
    console.log('====================')
    console.log(`ğŸ“Š æ€»è®¡é”®æ•°: ${allKeys.length}`)
    console.log(`âœ… æˆåŠŸç¿»è¯‘: ${successCount}`)
    console.log(`â­ï¸ è·³è¿‡ç¿»è¯‘: ${skippedCount}`)
    console.log(`âŒ å¤±è´¥ç¿»è¯‘: ${failureCount}`)
  } catch (error) {
    console.error('âŒ é¡ºåºç¿»è¯‘è¿‡ç¨‹å¤±è´¥:', error)
    throw error
  }
}
```

> ä½†å³ä½¿è¿™æ ·ï¼Œä¹Ÿéœ€è¦æ³¨æ„é•¿æ–‡æœ¬ï¼Œå‡è®¾ä¸€ä¸ªKey 5000å­—ï¼Œé‚£åªèƒ½é€šè¿‡å•Keyç¿»è¯‘ã€é™å®šè¢«ç¿»è¯‘è¯­è¨€ã€å¤§Keyåˆ†æ®µçš„æ–¹å¼æ¥è§£å†³äº†ï¼Œä½†è¿™ç§åœºæ™¯æœ‰ç‚¹æç«¯äº†ï¼Œè°å®¶å¥½äººä¸€ä¸ªkeyå†™5000å­—~

## æ·»åŠ I18Nçš„SEO

è¿™ä¸€èŠ‚çš„ç‰ˆæœ¬æ˜¯ [github tag v2.3.0](https://github.com/Shiinama/next-cloudflare-template/tree/v2.3.0)ã€‚

### æ·»åŠ è¯­è¨€åˆ‡æ¢é“¾æ¥

åœ¨`layout`ä¸­çš„`metadata`æ·»åŠ è¿™æ ·ä¸€æ®µï¼Œå³å¯ï¼Œ`x-default`è¡¨ç¤ºçš„æ˜¯é»˜è®¤è¯­è¨€ï¼Œ`NEXT_PUBLIC_BASE_URL`ä¹Ÿè¦æ·»åŠ åˆ°ç¯å¢ƒå˜é‡ä¸­ã€‚

```tsx
 alternates: {
    languages: {
      'x-default': process.env.NEXT_PUBLIC_BASE_URL,
      ...Object.fromEntries(
        locales.map((locale) => [locale.code, `${process.env.NEXT_PUBLIC_BASE_URL}/${locale.code}`])
      )
    }
  }
```

è¿™æ®µä»£ç ä¼šä¸ºæ¯ä¸ªæ”¯æŒçš„è¯­è¨€ç”Ÿæˆä¸€ä¸ªå¤‡ç”¨é“¾æ¥ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

```html
<link rel="alternate" hreflang="en" href="https://your-domain.com/en" />
<link rel="alternate" hreflang="zh" href="https://your-domain.com/zh" />
<link rel="alternate" hreflang="ja" href="https://your-domain.com/ja" />
<!-- å…¶ä»–è¯­è¨€... -->
<link rel="canonical" href="https://your-domain.com/å½“å‰è¯­è¨€" />
```

### é…ç½®sitemap.xml

ä¸ºäº†ç¡®ä¿æœç´¢å¼•æ“èƒ½å¤Ÿæ­£ç¡®çˆ¬å–å’Œç´¢å¼•æ‰€æœ‰è¯­è¨€ç‰ˆæœ¬çš„é¡µé¢ï¼Œæˆ‘ä»¬éœ€è¦é…ç½®sitemap.xmlï¼š

```ts
// app/sitemap.ts
import { MetadataRoute } from 'next'

import { locales } from '@/i18n/routing'

export const runtime = 'edge'

export default function sitemap(): MetadataRoute.Sitemap {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL

  // å®šä¹‰æ‰€æœ‰è·¯ç”±ï¼ˆä¸åŒ…å«è¯­è¨€ä»£ç ï¼‰
  const routes = ['', '/about']

  // ä¸ºæ¯ä¸ªè·¯ç”±å’Œæ¯ç§è¯­è¨€åˆ›å»ºsitemapæ¡ç›®
  const entries: MetadataRoute.Sitemap = []

  for (const route of routes) {
    for (const locale of locales) {
      entries.push({
        url: `${baseUrl}/${locale.code}${route}`
      })
    }
  }

  return entries
}
```

### é…ç½®å¤šè¯­è¨€çš„MetaData

é¦–å…ˆå®ŒæˆLayoutç»„ä»¶çš„MetaData.

```tsx
export async function generateMetadata(): Promise<Metadata> {
  const t = await getTranslations('siteInfo.meta')

  return {
    title: t('title'),
    description: t('description'),
    icons: {
      icon: '/logo.svg'
    },
    authors: [{ name: 'Felix', url: 'https://github.com/Shiinama' }],
    creator: 'Felix',
    openGraph: {
      images: ['/logo.svg']
    },
    alternates: {
      languages: {
        'x-default': process.env.NEXT_PUBLIC_BASE_URL,
        ...Object.fromEntries(
          locales.map((locale) => [locale.code, `${process.env.NEXT_PUBLIC_BASE_URL}/${locale.code}`])
        )
      }
    }
  }
}
```

æ¥åˆ°é¦–é¡µå®Œæˆé…ç½®ï¼Œå…¶ä»–é¡µé¢ä¹Ÿç±»ä¼¼çš„å†™æ³•

```tsx
export async function generateMetadata(): Promise<Metadata> {
  const t = await getTranslations('HomePage.meta')
  const site = await getTranslations('siteInfo')

  return {
    title: t('title', {
      brandName: site('brandName')
    }),
    description: t('description', {
      brandName: site('brandName')
    })
  }
}
```

## ç»“æŸ

å…³äºè„šæœ¬å’ŒI18nï¼Œå¤§å®¶è¦å¤šç”¨å¤šè¯•ï¼Œ`pnpm i18n:translate`æ¯æ¬¡å†™å®Œå·®ä¸å¤šäº†ï¼Œå¯ä»¥å°±è°ƒä¸€ä¸‹ï¼Œ`pnpm i18n:delete "keys"`æ˜¯ç”¨äºåˆ é™¤æ‰€æœ‰æ–‡ä»¶çš„keyï¼Œ`i18n:keys "keys"`æ˜¯ç”¨äºæ›¿æ¢ä¸æ»¡æ„çš„æ–‡æ¡ˆï¼Œè¿›è¡Œé‡æ–°ç”Ÿæˆçš„ã€‚

å½“è¿™ä¸€èŠ‚æˆ‘ä»¬ç†è§£äº†I18nï¼Œä¸‹ä¸€èŠ‚æˆ‘ä»¬å°±è®²è‡ªåŠ¨ç”Ÿæˆ`Blog`å†…å®¹ï¼Œè¿™æ˜¯ç”¨äº`Google`çš„æ’åçš„.

// lib/api-client.ts
const apiClient = {
  async get(url: string, options = {}) {
    return this.request('GET', url, null, options);
  },
  
  async post(url: string, data: any, options = {}) {
    return this.request('POST', url, data, options);
  },
  
  // å…¶ä»–æ–¹æ³•...
  
  async request(method: string, url: string, data: any = null, options = {}) {
    try {
      const response = await fetch(`/api${url}`, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: data ? JSON.stringify(data) : undefined,
        ...options,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        return response.json();
      }

      return response.text();
    } catch (error) {
      console.error('Request failed:', error);
      throw error;
    }
  },
};
