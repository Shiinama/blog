# 最简项目-CloudFlare的生态的完全打开

目前为止整个项目的涉及的后端基建是有所欠缺的，例如队列、定时器、内存KV、Websocket等。这些能力不是在实现一个最简项目中必须的，但是能帮助大家更好的理解后端生态、架构，以及在未来有一天所需的时候把这些基建从尘封的记忆中唤起。

这些部分都能够完整的通过Cloudflare生态来实现，非常感谢xxgw的带来的B站视频链接，是因为视频才有了这个章节的补充。

## 改变Worker的入口

首先，为了能够自定义Cloudflare Worker的行为，我们需要修改项目的 `wrangler.jsonc` 配置文件。将 `main` 属性指向一个新的入口文件 `worker.ts`。这个文件将作为我们所有Cloudflare后端服务的统一入口，而不仅仅是运行Next.js应用。

```jsonc
// wrangler.jsonc
{
  // ...
  "main": "worker.ts"
  // ...
}
```

接下来，我们创建 `worker.ts` 文件。这个文件的核心思想是：在处理Next.js应用本身请求的同时，扩展支持Cloudflare的其他原生功能，如定时任务（Cron Triggers）,Durable等。

```typescript
// 1. 导入由 open-next 生成的 Next.js 应用处理器
// @ts-ignore `.open-next/worker.ts` 是在构建时生成的
import { default as handler } from './.open-next/worker.js'

// 2. 导出一个包含 fetch 和 scheduled 处理器的对象
export default {
  /**
   * 处理所有传入的 HTTP 请求。
   * 我们将请求直接委托给 open-next 的处理器，以确保 Next.js 应用正常运行。
   */
  fetch: handler.fetch,

  /**
   * 处理由 Cron Triggers 触发的定时任务。
   * Cloudflare 会在预定时间调用此函数。
   */
  async scheduled(controller: ScheduledController, env: CloudflareEnv, ctx: ExecutionContext) {
    // 你可以根据 wrangler.jsonc 中定义的 cron 表达式来执行不同的任务
    switch (controller.cron) {
      case '*/3 * * * *':
        // 每三分钟执行一次
        console.log('Cron job (every 3 mins) processed at:', new Date(controller.scheduledTime))
        break
      case '*/10 * * * *':
        // 每十分钟执行一次
        console.log('Cron job (every 10 mins) processed at:', new Date(controller.scheduledTime))
        break
      case '*/45 * * * *':
        // 每四十五分钟执行一次
        console.log('Cron job (every 45 mins) processed at:', new Date(controller.scheduledTime))
        break
    }
  }
} satisfies ExportedHandler<CloudflareEnv>

// 3. 重新导出 open-next 和自定义的 Durable Objects 处理器
// 这确保了 Cloudflare 平台能够正确识别和使用它们。
// @ts-ignore
export { DOQueueHandler, DOShardedTagCache, BucketCachePurge } from './.open-next/worker.js'
export { Counter } from './durable/counter.js'
```

到这里，我们已经完成了将 Next.js 应用与自定义 Worker 逻辑（如定时任务）集成的关键一步。所有 Cloudflare 生态的扩展都可以在 worker.ts 中进行配置和导出。

接下来，我们可以将 Cloudflare 的生态功能大致归为两大类：配置驱动型功能和类扩展型功能。理解这两者的区别有助于我们更清晰地组织代码和配置。

1.  配置驱动型功能 (Configuration-Driven)
    这类功能（如定时器、队列）的核心工作模式是“先配置，后处理”。你首先需要在 wrangler.jsonc 文件中声明它们的触发规则或绑定信息。然后，在 worker.ts 文件中，你需要实现一个对应的处理器函数（例如 scheduled 用于定时器，queue 用于队列）来响应这些事件并执行具体的业务逻辑。
2.  类扩展型功能 (Class-Based Extension)
    这类功能的代表就是 Durable Objects (DO)。它的工作模式是“先定义，后绑定”。你需要先编写一个独立的类（Class）来封装其状态和方法，定义其完整的行为。之后，在 wrangler.jsonc 中配置这个类并创建一个绑定，最后在 worker.ts 中导出这个类，让 Cloudflare 平台能够识别并实例化它。这种方式非常适合构建有状态的、可复用的后端组件。

## 配置驱动型: 定时器

首先从相对简单的配置驱动型功能——定时器开始。

这部分就非常的简单，只需要在 `wrangler.jsonc` 的 `triggers` 部分中添加 cron 表达式，之后就会在 `Worker.ts` 处理器中执行。

```
"triggers": {
    "crons": [
        "*/3 * * * *",
        "*/10 * * * *",
        "*/45 * * * *"
    ]
}
```

```typescript
async scheduled(controller: ScheduledController, env: CloudflareEnv, ctx: ExecutionContext) {
  // 你可以根据 wrangler.jsonc 中定义的 cron 表达式来执行不同的任务
  switch (controller.cron) {
    case '*/3 * * * *':
      // 每三分钟执行一次
      console.log('Cron job (every 3 mins) processed at:', new Date(controller.scheduledTime))
      break
    case '*/10 * * * *':
      // 每十分钟执行一次
      console.log('Cron job (every 10 mins) processed at:', new Date(controller.scheduledTime))
      break
    case '*/45 * * * *':
      // 每四十五分钟执行一次
      console.log('Cron job (every 45 mins) processed at:', new Date(controller.scheduledTime))
      break
  }
}
```

## 类扩展型: Durable Objects

**什么是 Durable Objects (DO)？**

Durable Objects 为通常是无状态的 Cloudflare Workers 提供了一种强一致性、有状态的存储和计算能力。你可以把它想象成一个有自己持久化存储的、可被寻址的单例对象。它非常适合需要为特定实体（如聊天室、协作文档、购物车或本例中的计数器）维护状态的场景。

我们将通过三个步骤来实现一个简单的计数器 DO：

1.  编写 `Counter` DO 类。
2.  在 `wrangler.jsonc` 中配置并绑定它。
3.  在 Next.js API 路由中调用它。

### 步骤 1: 编写 Durable Object 类

首先，我们创建一个 `Counter` 类。这个类定义了 DO 的内部状态和行为。

```typescript
// File: durable/counter.ts
import { DurableObject } from 'cloudflare:workers'

// Counter 类定义了 Durable Object 的行为和持久化逻辑
export class Counter extends DurableObject {
  // 从持久化存储中获取当前计数值
  async getCounterValue() {
    // this.ctx.storage 是与此特定 DO 实例绑定的持久化存储
    const value: number = (await this.ctx.storage.get('value')) || 0
    return value
  }

  // 增加计数值
  async increment(amount = 1) {
    const value = await this.getCounterValue()
    const newValue = value + amount
    // 将新值存回持久化存储
    await this.ctx.storage.put('value', newValue)
    return newValue
  }

  // 减少计数值
  async decrement(amount = 1) {
    const value = await this.getCounterValue()
    const newValue = value - amount
    await this.ctx.storage.put('value', newValue)
    return newValue
  }
}
```

### 步骤 2: 在 `wrangler.jsonc` 中配置 DO

定义好类之后，我们需要告诉 Cloudflare 它的存在，并为它创建一个绑定，以便我们的 Worker 可以访问它。同时，还需要添加一个迁移记录。

```jsonc
// File: wrangler.jsonc
{
  // ...
  "durable_objects": {
    "bindings": [
      // ... open-next 的默认绑定
      {
        "name": "COUNTER_DO",
        "class_name": "Counter"
      }
    ]
  },
  "migrations": [
    // ... open-next 的默认迁移
    {
      "tag": "v2", // 使用一个新的版本标签
      "new_classes": [
        "Counter" // 声明新的 DO 类
      ]
    }
  ]
  // ...
}
```

**配置解析:**

- `durable_objects.bindings`: 我们添加了一个新的绑定。`"name": "COUNTER_DO"` 定义了在 Worker 环境变量中访问此 DO 的名称。`"class_name": "Counter"` 将其链接到我们刚刚创建的 `Counter` 类。
- `migrations`: 每次添加新的 DO 类时，都需要添加一条迁移记录，以告知 Cloudflare 平台进行相应的更新。

最后在 `worker.ts` 中导出这个新类：

```typescript
// File: worker.ts
// ... existing code
export { Counter } from './durable/counter.js'
```

### 步骤 3: 从 Next.js API 路由访问 DO

现在，我们可以在 Next.js 应用内部（例如 API 路由或 Server Action）与我们的 `Counter` DO 进行交互了。

首先，创建一个辅助函数来获取 DO。

```typescript
import { getCloudflareContext } from '@opennextjs/cloudflare'

export const getCounterDO = () => {
  const cf = getCloudflareContext()
  // 我们使用一个固定的名称 "singleton" 来确保我们总是与同一个 DO 实例交互。
  // 您也可以根据用户ID、文档ID等动态生成名称。
  const id = cf.env.COUNTER_DO.idFromName('singleton')
  return cf.env.COUNTER_DO.get(id)
}
```

这里很有意思的是 `idFromName`，我们可以用**动态的、唯一的字符串**来创建无数个独立的 DO 实例。这为实现多租户或用户隔离的复杂场景提供了极大的便利。

举个简单的例子：想象一下，我们想为网站的每个用户都提供一个持久化的购物车。使用 Durable Objects，我们不需要为每个用户的购物车数据单独创建数据库表或行。我们可以直接为每个用户创建一个 `ShoppingCart` DO 实例。

```typescript
import { getCloudflareContext } from '@opennextjs/cloudflare'
import { getSession } from 'next-auth/react' // 或其他获取用户ID的方式

// 这个函数根据用户ID获取对应的购物车DO
export async function getShoppingCartDO() {
  const session = await getSession()
  const userId = session?.user?.id

  if (!userId) {
    throw new Error('User not authenticated')
  }

  const cf = getCloudflareContext()

  // @ts-ignore
  const durableObject = cf.env.SHOPPING_CART_DO

  // 使用用户的唯一ID作为DO实例的名称
  // 这确保了每个用户都获得自己独立的、持久化的购物车实例
  const id = durableObject.idFromName(userId)
  return durableObject.get(id)
}
```

**工作原理：**

1.  当用户 `user-alice` 登录并添加商品时，我们调用 `getShoppingCartDO()`。函数内部会执行 `idFromName('user-alice')`，Cloudflare 会为 Alice 创建或唤醒一个专属于她的 `ShoppingCart` 实例。
2.  当另一个用户 `user-bob` 操作他的购物车时，`idFromName('user-bob')` 会定位到另一个完全独立的 `ShoppingCart` 实例。
3.  Alice 的购物车状态（例如商品列表、数量）会持久化在她的 DO 实例中，与 Bob 的购物车完全隔离。

通过这种方式，`idFromName` 将用户身份直接映射到了一个有状态的后端实体，极大地简化了为每个用户维护独立状态的架构设计。

当然我们言归正传啊，继续我们模版项目里的API实现

```typescript
// File: app/api/counter/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getCounterDO } from '@/lib/durable'

export const runtime = 'edge'

export async function GET(request: NextRequest) {
  // 从 URL 获取要执行的操作
  const action = request.nextUrl.searchParams.get('action')

  if (!action || !['increment', 'decrement', 'current'].includes(action)) {
    return NextResponse.json({ error: 'Invalid action' }, { status: 400 })
  }

  // 获取 DO 的 stub
  const stub = getCounterDO()
  let data: any

  // 根据操作调用 DO 上的相应方法
  if (action === 'current') {
    data = await stub.getCounterValue()
  } else if (action === 'increment') {
    data = await stub.increment()
  } else if (action === 'decrement') {
    data = await stub.decrement()
  }

  return NextResponse.json({ count: data })
}
```

现在，当你部署应用后，就可以通过访问 `/api/counter?action=increment` 来增加计数器的值，并通过 `/api/counter?action=current` 来获取当前值。这展示了如何将一个有状态的服务集成到一个基于 Next.js 的无状态应用中。

## 总结

这一章的核心在于通过一个自定义的 worker.ts 入口文件，我们不仅保留了 open-next 带来的全部功能，还为应用开启了通往 Cloudflare 原生服务的大门，通过掌握这两种集成模式，你就可以灵活地组合 Cloudflare 的各项服务，将 Next.js 应用与强大的后端生态无缝集成，构建出功能丰富、性能卓越的全栈应用。
