# 最简AI项目：第二版项目优化

在`http://destinyai.tools`这个项目使用模版的实践中，我感受到了存在目前基建项目中的许多不足和问题，因此我将对其进行一些重点的优化。

[本节Tag](https://github.com/Shiinama/next-cloudflare-template/tree/v8.0.1)

## 项目打包产物的大小问题

`"@opennextjs/cloudflare": "^1.2.1",`这个版本极大的减少打包产物的大小。

![](https://ik.imagekit.io/ixou4q6nu/press-image.png?updatedAt=1749892608130)

可以看到实际上，打包产物小了很多倍，这让可以免费使用Cloudflare Worker，不超过3M的限制。

## 项目图片的生产

在项目中需要很多的图片，不管是封面图、还是在各种版面上，所以图片生成的大小、尺寸、比列、质量都挺重要的。

因此支持一下图片场景更复杂的生成，位置在`actions/ai.ts`，用的是sdxl的蒸馏模型，主要是支持宽高比：

```typescript
export async function cloudflareTextToImage({
  prompt,
  negativePrompt,
  ratio = '16:9',
  style = 'realistic',
  customWidth,
  customHeight,
  steps = 8,
  seed
}: ImageGenerationOptions) {
  try {
    const ai = createAI()
    const r2 = createR2()

    const enhancedPrompt = `${prompt}, ${styleEnhancers[style]}`

    const finalNegativePrompt = negativePrompt
      ? `${negativePrompt}, ${styleNegativePrompts[style]}`
      : styleNegativePrompts[style]

    const { width, height } = getDimensions(ratio, customWidth, customHeight)

    const response = await ai.run('@cf/bytedance/stable-diffusion-xl-lightning', {
      prompt: enhancedPrompt,
      negative_prompt: finalNegativePrompt,
      height,
      width,
      num_steps: steps,
      seed: seed || Math.floor(Math.random() * 2147483647)
    })

    const reader = response.getReader()
    const chunks: Uint8Array[] = []
    let done, value

    while ((({ done, value } = await reader.read()), !done)) {
      chunks.push(value!)
    }

    const imageBuffer = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0))
    let offset = 0
    for (const chunk of chunks) {
      imageBuffer.set(chunk, offset)
      offset += chunk.length
    }

    const base64Image = `data:image/png;base64,${Buffer.from(imageBuffer).toString('base64')}`

    const sanitizedPrompt = prompt.replace(/[^a-zA-Z0-9]/g, '-').substring(0, 30)
    const timestamp = Date.now()
    const filename = `${timestamp}-${sanitizedPrompt}-${width}x${height}.png`

    try {
      await r2.put(filename, imageBuffer, {
        httpMetadata: {
          contentType: 'image/png'
        }
      })
    } catch (r2Error) {
      console.error('Error storing image in R2:', r2Error)
    }

    return {
      success: true,
      imageData: base64Image,
      imageUrl: filename,
      error: null,
      metadata: {
        prompt: enhancedPrompt,
        negativePrompt: finalNegativePrompt,
        width,
        height,
        steps,
        seed,
        style,
        timestamp
      }
    }
  } catch (error) {
    console.error('Error generating image:', error)
    return {
      success: false,
      imageData: null,
      imageUrl: null,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    }
  }
}
```

前端代码主要在`components/image-generator/image-generator.tsx`，没有什么特别可以讲的。

> 值得注意的是Stable Diffusion系的模型，提示词要以短关键词的方式来完成，而现代的图像模型Transformers系的图像模型是支持自然语言描述的。

## 防刷、移除掉I18n的强制规则、去除掉非必要的I18n等

首先把AI生图文字和图片都移动到了Admin下，防刷。

其次实际上并不是所有的内容都需要I18n,现在Admin目录下有生图, 文本生成, 生成文章等页面，都可以去除。

执行`pnpm i18n:delete "admin"`，然后AI跑一遍全部替换成中文即可。

另外重构了整个文章管理的UI实现，使其更容易操作和管理已经上线的文章。

## 为博客文章添加生图的功能

实际上，即使文章本身的内容中可以插入图片，但是文章还是需要封面图。

首先在表结构中添加`coverImageUrl`，跑`pnpm db:generate`、`pnpm db:migrate-local`。

```typescript
export const posts = sqliteTable('posts', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  slug: text('slug').notNull().unique(),
  title: text('title').notNull(),
  coverImageUrl: text('cover_image_url'),
  excerpt: text('excerpt').notNull(),
  content: text('content').notNull(),
  locale: text('locale').notNull().default('en'), // Add locale field with default 'en'
  publishedAt: integer('published_at', { mode: 'timestamp_ms' }),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull()
})
```

生图的核心是，这里的做法实际就是采用先转译成适配Stable Diffusion的短提示词格式，再给到图像模型进行生图：

```typescript
export async function generateArticleCoverImage(articleContent: string, title: string) {
  const cloudflareAI = createAI()

  const promptGenerationResult = await cloudflareAI.run('@cf/meta/llama-4-scout-17b-16e-instruct', {
    messages: [
      {
        role: 'system',
        content: `You are an expert at creating Stable Diffusion prompts. 
          
          Create a prompt for a 16:9 cover image that represents the article's main theme.
          
          Guidelines for the prompt:
          - Use a comma-separated list of keywords and short phrases
          - Include visual elements, style descriptors, and mood indicators
          - Focus on concrete visual elements rather than abstract concepts
          - Include 5-20 keywords maximum
          - DO NOT use full sentences or narrative descriptions
          - DO NOT include negative prompts
          - DO NOT include quotation marks or other formatting
          
          Example good prompts:
          - mountain landscape, sunrise, golden light, fog, dramatic vista, 16k
          - business meeting, professional setting, modern office, teamwork, corporate
          - healthy food, fresh vegetables, vibrant colors, wooden table, soft lighting`
      },
      {
        role: 'user',
        content: `Create a Stable Diffusion prompt for a cover image for an article titled: "${title}". 
          
          Here's the beginning of the article content for context: "${articleContent.substring(0, 500)}..."
          
          Return ONLY the comma-separated keywords without any explanation or additional text.`
      }
    ],
    stream: false
  })

  let imagePrompt = title
  if (typeof promptGenerationResult === 'object') {
    // Clean up the response to ensure it's just the keywords
    const response = promptGenerationResult.response.trim()
    // Remove any explanatory text, quotation marks, or other formatting
    imagePrompt = response
      .replace(/^["']|["']$/g, '') // Remove surrounding quotes
      .replace(/^(prompt:|keywords:|here's a prompt:|stable diffusion prompt:)/i, '') // Remove prefixes
      .replace(/\.$/g, '') // Remove trailing period
      .trim()
  }

  // Generate the cover image using the created prompt
  const imageResult = await cloudflareTextToImage({
    prompt: imagePrompt,
    ratio: '16:9',
    style: 'cinematic', // Using cinematic style for professional-looking cover images
    steps: 12, // Higher quality generation
    negativePrompt: 'text, watermark, signature, blurry, distorted, low quality, disfigured'
  })

  return imageResult.imageUrl
}
```

其余也是前端的UI部分，给文章编辑、新增都增加图片重新生成的部分，可以直接生成图片。以及给生成的文章插入封面图等。

![](https://ik.imagekit.io/ixou4q6nu/gen-image-blog.png?updatedAt=1749893213298)

## 新模型的推荐

我强烈推荐Google生态系的模型，首先是AI文字方面，2.5Pro + Google Search，是可以跟OpenAI O3模型有一拼的。（不得不吐槽啊，就是海外的顶级效果模型，国内的媒体渠道是一口不提啊）。

他们的生图模型，是支持自然语言的，同样有不错的反馈和提示词理解。

最终是价格，只有OpenAI的10分之1。加入如果绑定了Google Cloud送的300$，几乎就等于免费。

## 添加项目的路由切换效果

所有的操作都必须给用户反馈，这是一个在UI交互里面的原则。但实际上，目前我们的项目在路由加载的时候，用户就干等着，不知道发生了什么（人家还以为网页就是卡了）。

但在`Nextjs`给所有路由添加的反馈的方式是在跟目录下加一个`loading.tsx`，这有两个很大的问题：一个问题是出现Loading的状态时间也需要等待，可能是在点击路由跳转几百毫秒后才可以出现`loading`。另外一个问题是在于，`loading.tsx`是会导致所有页面在外层强行加上`suspense`，我特别烦这种强制破坏你所有布局的设计方式。

那么我的解法是什么那？用一个网页加载的进度条去解决这个问题，把进度条放在最外层的`layout.tsx`里，监控原生路由跳转去展示进度条，主要的核心文件位置在`components/top-loader.tsx`。

```typescript
const NextTopLoader = ({
  color: propColor,
  height: propHeight,
  showSpinner,
  crawl,
  crawlSpeed,
  initialPosition,
  easing,
  speed,
  shadow,
  template,
  zIndex = 1600,
  showAtBottom = false,
  showForHashAnchor = true
}: NextTopLoaderProps): React.JSX.Element => {
  // 定义默认颜色为蓝色
  const defaultColor = '#29d'
  // 定义默认高度为3像素
  const defaultHeight = 3

  // 使用提供的颜色或默认颜色
  const color = propColor ?? defaultColor
  // 使用提供的高度或默认高度
  const height = propHeight ?? defaultHeight

  // 处理阴影效果
  // 如果shadow是false，则不显示阴影
  // 如果提供了自定义shadow，则使用自定义值
  // 否则使用默认阴影效果
  const boxShadow =
    !shadow && shadow !== undefined
      ? ''
      : shadow
        ? `box-shadow:${shadow}`
        : `box-shadow:0 0 10px ${color},0 0 5px ${color}`

  // 确定进度条的位置样式，默认在顶部，可选择在底部
  const positionStyle = showAtBottom ? 'bottom: 0;' : 'top: 0;'
  // 确定加载旋转图标的位置样式
  const spinnerPositionStyle = showAtBottom ? 'bottom: 15px;' : 'top: 15px;'

  /**
   * 为NextTopLoader定义CSS样式
   */
  const styles = (
    <style>
      {`#nprogress{pointer-events:none}#nprogress .bar{background:${color};position:fixed;z-index:${zIndex};${positionStyle}left:0;width:100%;height:${height}px}#nprogress .peg{display:block;position:absolute;right:0;width:100px;height:100%;${boxShadow};opacity:1;-webkit-transform:rotate(3deg) translate(0px,-4px);-ms-transform:rotate(3deg) translate(0px,-4px);transform:rotate(3deg) translate(0px,-4px)}#nprogress .spinner{display:block;position:fixed;z-index:${zIndex};${spinnerPositionStyle}right:15px}#nprogress .spinner-icon{width:18px;height:18px;box-sizing:border-box;border:2px solid transparent;border-top-color:${color};border-left-color:${color};border-radius:50%;-webkit-animation:nprogress-spinner 400ms linear infinite;animation:nprogress-spinner 400ms linear infinite}.nprogress-custom-parent{overflow:hidden;position:relative}.nprogress-custom-parent #nprogress .bar,.nprogress-custom-parent #nprogress .spinner{position:absolute}@-webkit-keyframes nprogress-spinner{0%{-webkit-trans`}
    </style>
  )

  /**
   * 将相对URL转换为绝对URL
   * @param url {string} 需要转换的URL
   * @returns {string} 转换后的绝对URL
   */
  const toAbsoluteURL = (url: string): string => {
    return new URL(url, window.location.href).href
  }

  /**
   * 检查URL是否为哈希锚点或同页面锚点
   * @param currentUrl {string} 当前URL位置
   * @param newUrl {string} 带有锚点的新URL
   * @returns {boolean} 是否为哈希锚点
   */
  const isHashAnchor = (currentUrl: string, newUrl: string): boolean => {
    const current = new URL(toAbsoluteURL(currentUrl))
    const next = new URL(toAbsoluteURL(newUrl))
    // 比较URL去掉哈希部分后是否相同
    return current.href.split('#')[0] === next.href.split('#')[0]
  }

  /**
   * 检查两个URL是否属于同一主机名
   * @param currentUrl {string} 当前URL位置
   * @param newUrl {string} 新URL
   * @returns {boolean} 是否为同一主机名
   */
  const isSameHostName = (currentUrl: string, newUrl: string): boolean => {
    const current = new URL(toAbsoluteURL(currentUrl))
    const next = new URL(toAbsoluteURL(newUrl))
    // 比较主机名（忽略www前缀）
    return current.hostname.replace(/^www\./, '') === next.hostname.replace(/^www\./, '')
  }

  React.useEffect((): ReturnType<React.EffectCallback> => {
    // 配置NProgress进度条的行为
    NProgress.configure({
      showSpinner: showSpinner ?? true, // 是否显示加载旋转图标
      trickle: crawl ?? true, // 是否启用自动增长
      trickleSpeed: crawlSpeed ?? 200, // 自动增长的速度
      minimum: initialPosition ?? 0.08, // 初始位置（百分比）
      easing: easing ?? 'ease', // 动画缓动函数
      speed: speed ?? 200, // 动画速度
      // HTML模板
      template:
        template ??
        '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    })

    /**
     * 检查当前URL和新URL是否为同一页面的不同锚点
     * @param currentUrl {string} 当前URL
     * @param newUrl {string} 新URL
     * @returns {boolean} 是否为同一页面的不同锚点
     */
    function isAnchorOfCurrentUrl(currentUrl: string, newUrl: string): boolean {
      const currentUrlObj = new URL(currentUrl)
      const newUrlObj = new URL(newUrl)
      // 比较主机名、路径和搜索参数
      if (
        currentUrlObj.hostname === newUrlObj.hostname &&
        currentUrlObj.pathname === newUrlObj.pathname &&
        currentUrlObj.search === newUrlObj.search
      ) {
        // 检查新URL是否只是当前URL页面的锚点
        const currentHash = currentUrlObj.hash
        const newHash = newUrlObj.hash
        return (
          currentHash !== newHash && currentUrlObj.href.replace(currentHash, '') === newUrlObj.href.replace(newHash, '')
        )
      }
      return false
    }

    // 获取所有HTML元素，用于移除nprogress-busy类
    // deno-lint-ignore no-var
    const nProgressClass: NodeListOf<HTMLHtmlElement> = document.querySelectorAll('html')

    // 移除nprogress-busy类的函数
    const removeNProgressClass = (): void =>
      nProgressClass.forEach((el: Element) => el.classList.remove('nprogress-busy'))

    /**
     * 查找最近的锚点元素
     * @param element {HTMLElement | null} 起始元素
     * @returns {HTMLAnchorElement | null} 找到的锚点元素
     */
    function findClosestAnchor(element: HTMLElement | null): HTMLAnchorElement | null {
      while (element && element.tagName.toLowerCase() !== 'a') {
        element = element.parentElement
      }
      return element as HTMLAnchorElement
    }

    /**
     * 处理点击事件
     * @param event {MouseEvent} 鼠标点击事件
     * @returns {void}
     */
    function handleClick(event: MouseEvent): void {
      try {
        const target = event.target as HTMLElement
        // 查找被点击元素最近的锚点
        const anchor = findClosestAnchor(target)
        const newUrl = anchor?.href
        if (newUrl) {
          const currentUrl = window.location.href
          // 检查是否为外部链接（有target属性）
          const isExternalLink = ((anchor as HTMLAnchorElement).target as React.HTMLAttributeAnchorTarget) !== ''

          // 检查是否为特殊协议链接
          const isSpecialScheme = ['tel:', 'mailto:', 'sms:', 'blob:', 'download:'].some((scheme) =>
            newUrl.startsWith(scheme)
          )

          // 检查是否为不同主机名
          const notSameHost = !isSameHostName(window.location.href, anchor.href)
          if (notSameHost) {
            return
          }

          // 检查是否为锚点或哈希锚点
          const isAnchorOrHashAnchor =
            isAnchorOfCurrentUrl(currentUrl, newUrl) || isHashAnchor(window.location.href, anchor.href)
          if (!showForHashAnchor && isAnchorOrHashAnchor) {
            return
          }

          // 根据不同情况决定是否显示进度条
          if (
            newUrl === currentUrl || // 相同URL
            isExternalLink || // 外部链接
            isSpecialScheme || // 特殊协议
            isAnchorOrHashAnchor || // 锚点链接
            event.ctrlKey || // Ctrl键点击
            event.metaKey || // Meta键点击
            event.shiftKey || // Shift键点击
            event.altKey || // Alt键点击
            !toAbsoluteURL(anchor.href).startsWith('http') // 非HTTP链接
          ) {
            // 对于特殊情况，立即开始并完成进度条
            NProgress.start()
            NProgress.done()
            removeNProgressClass()
          } else {
            // 对于正常导航，开始进度条
            NProgress.start()
          }
        }
      } catch (err) {
        // 捕获错误并确保进度条完成
        // 开发环境可以取消注释下面的日志
        // console.log('NextTopLoader error: ', err);
        NProgress.start()
        NProgress.done()
      }
    }

    /**
     * 监听历史记录pushState方法，在添加新条目到历史堆栈时完成进度条
     * @param {History} 浏览器历史对象
     * @returns {void}
     */
    ;((history: History): void => {
      const pushState = history.pushState
      history.pushState = (...args) => {
        NProgress.done()
        removeNProgressClass()
        return pushState.apply(history, args)
      }
    })((window as Window).history)

    /**
     * 监听历史记录replaceState方法，在替换当前历史条目时完成进度条
     * @param {History} 浏览器历史对象
     * @returns {void}
     */
    ;((history: History): void => {
      const replaceState = history.replaceState
      history.replaceState = (...args) => {
        NProgress.done()
        removeNProgressClass()
        return replaceState.apply(history, args)
      }
    })((window as Window).history)

    /**
     * 处理页面隐藏事件
     * @returns {void}
     */
    function handlePageHide(): void {
      NProgress.done()
      removeNProgressClass()
    }

    /**
     * 处理浏览器前进后退导航
     * @returns {void}
     */
    function handleBackAndForth(): void {
      NProgress.done()
    }

    // 添加全局事件监听器
    window.addEventListener('popstate', handleBackAndForth) // 监听历史记录变化
    document.addEventListener('click', handleClick) // 监听点击事件
    window.addEventListener('pagehide', handlePageHide) // 监听页面隐藏事件

    // 组件卸载时清理全局事件监听器
    return (): void => {
      document.removeEventListener('click', handleClick)
      window.removeEventListener('pagehide', handlePageHide)
      window.removeEventListener('popstate', handleBackAndForth)
    }
  }, [])

  // 返回样式元素
  return styles
```

那么仅此还是不够的，还需要处理使用useRouter跳转的时候出现的进度条，位置在`i18n/navigation.ts`

```typescript
'use client'

import { NavigateOptions } from 'next/dist/shared/lib/app-router-context.shared-runtime'
import { createNavigation } from 'next-intl/navigation'
import * as NProgress from 'nprogress'
import { useCallback, useEffect } from 'react'

import { routing } from './routing'

// Lightweight wrappers around Next.js' navigation
// APIs that consider the routing configuration
const { Link, redirect, usePathname, useRouter: UseI18nRouter, getPathname } = createNavigation(routing)

const useRouter = () => {
  const router = UseI18nRouter()
  const pathname = usePathname()
  useEffect(() => {
    NProgress.done()
  }, [pathname])
  const replace = useCallback(
    (href: string, options?: NavigateOptions) => {
      if (href !== pathname) {
        NProgress.start()
      }
      router.replace(href, options)
    },
    [router, pathname]
  )

  const push = useCallback(
    (href: string, options?: NavigateOptions) => {
      if (href !== pathname) {
        NProgress.start()
      }
      router.push(href, options)
    },
    [router, pathname]
  )

  return {
    ...router,
    replace,
    push
  }
}

export { Link, redirect, useRouter, usePathname, getPathname }
```

最后给出一个手动控制进度条的Hooks，位置在`hooks/use-top-loader.ts`。

```typescript
export const useTopLoader = (): TopLoaderActions => {
  const actions: TopLoaderActions = {
    start: () => NProgress.start(),
    done: (force?: boolean) => NProgress.done(force),
    remove: () => NProgress.remove(),
    setProgress: (value: number) => NProgress.set(value),
    inc: (amount?: number) => NProgress.inc(amount),
    trickle: () => NProgress.trickle(),
    isStarted: () => NProgress.isStarted(),
    isRendered: () => NProgress.isRendered(),
    getPositioningCSS: () => NProgress.getPositioningCSS()
  }

  return actions
}
```
