# 所有连起来

最简项目的最终目的是，拿到项目上手就可以用。

在[8.01](https://github.com/Shiinama/next-cloudflare-template/tree/v8.0.1) 完成的是不需要支付（甚至不需要用户体系），只用做工具和内容，依靠工具实用性和SEO内容页获取流量，最终通过广告进行付费。

而在[10.1.0](https://github.com/Shiinama/next-cloudflare-template/tree/v10.1.0)，到又是一条分岔路口，大家可以以这个版本为母版，大家自由的把基建组合成自己喜欢的样子。

最后的两章中，我会以一个核心AI工具功能为目标，把所有的基建串联起来，达到一个可以开箱即用。大家只用更换核心功能就可以马上开始一个新项目的最终版本。

那么在这一章有两个主线任务：

1. 给大家讲述在做某个项目或者功能的心路历程。
2. 完成最基本的API组合和与基建的交互。

[当前版本](https://github.com/Shiinama/next-cloudflare-template/tree/v11.1.1)

## 从需求洞察到产品设计

在动手写代码之前，我们需要先理清楚商业逻辑。对于开发者来说，最常见的失败原因就是直接从技术能力出发，而不是从市场需求出发。

### 选择什么功能？

功能选择的核心在于**信息收集与分析**，这包括主动调研和被动观察两个维度。

以我最近开发的AI音频功能为例：这个需求来源于在Twitter上看到的一个[女性向英文语音小剧场](https://x.com/octmiya?s=11)，音频质量和情感表达都非常出色，这种内容极易分享和自传播。

我瞬间意识到AI音频在内容创作领域的巨大潜力，就开始找市面上的技术方案。经过对比20多家服务商的效果和定价，发现[ElevenLabs](https://elevenlabs.io/)在音频质量上具有明显优势，几乎没有同档次的竞争对手，但相应地，其API定价也是最高的。

### 从技术选型到产品定位

确定技术方案只是第一步，更关键的问题是：**如何将技术能力转化为用户价值？**

这里就涉及到产品思维中的一个核心概念：场景倒推 vs 技术正推。大多数开发者习惯从技术出发设计产品，这件事可能在一年前的AI行业里是可以的，但现在大家卷烂了，最好的方式还是从市场需求触发。

**技术正推的思路：**
我有ElevenLabs的API → 我可以做文字转语音 → 用户应该会需要这个功能 → 我做一个TTS工具

**场景倒推的思路：**
内容创作者需要高质量音频 → 他们的痛点是录音麻烦、声音不够专业 → 他们需要的是"让文字内容变成专业音频"

区别在哪里？前者关注的是技术能力，后者关注的是用户价值。前者做出来的是工具，后者做出来的是解决方案。

### 定位决定竞争策略

同样的TTS技术，不同的定位会面临完全不同的竞争环境：

如果定位成"AI音频工具"，你面临的就是价格战。用户会拿你和所有TTS工具比价格、比参数。

但如果定位成"内容创作者的音频解决方案"，你卖的就不是TTS功能，而是"让内容创作更高效"这个价值。用户关心的不是你用什么API，而是能不能解决他们的问题。

### 观察用户行为

紧接着就是去观察用户在这个场景下的行为是什么？我贿赂了几个Twitter的创作者，问了一下他们的流程，大致是：

1. 写好文案，生成一小段试听
2. 不满意，调整文案或换声音
3. 重新生成，再试听
4. 满意后分段生成完整内容
5. 用其他工具拼接调整
6. 最终发布

这告诉我们什么？用户需要的不是"一键生成完美音频"，而是"快速迭代的创作工具"。所以预览功能比完整生成更重要，版本管理比单次输出更有价值。

这时候就有开发的同学会说："那我做一个网页音频编辑器吧！"，这显然是不对的，对于音频编辑有更专心的软件，内容创作者几乎不会使用网页上的编辑器功能，而是在专业软件（如Adobe Audition、Audacity）进行精细编辑。

我们只是解决某一个环的事情，并不需要解决所有的问题，想得太多，很容易最后什么的最不好。

## 付费功能的计算

当我们的脑子里把产品的主线思路整理清楚后，接下来就需要考虑产品的`定价模型`。

### 核算成本

第一步是核算你使用的服务的成本。我们来到Elevenlabs定价：

![](https://ik.imagekit.io/ixou4q6nu/elevenlabs-pricing.png?updatedAt=1753342170530)

**Pro套餐 ($99/月)**

- **最高质量模型**: 500,000 credits (~500 min)
  - 1分钟价格: $99 ÷ 500 = **$0.198/分钟**
- **Turbo/Flash模型**: 1,000,000 credits (~1,000 min)
  - 1分钟价格: $99 ÷ 1,000 = **$0.099/分钟**

**Scale套餐 ($330/月)**

- **最高质量模型**: 2,000,000 credits (~2,000 min)
  - 1分钟价格: $330 ÷ 2,000 = **$0.165/分钟**
- **Turbo/Flash模型**: 4,000,000 credits (~4,000 min)
  - 1分钟价格: $330 ÷ 4,000 = **$0.0825/分钟**

**Business套餐 ($1320/月)**

- **最高质量模型**: 11,000,000 credits (~11,000 min)
  - 1分钟价格: $1320 ÷ 11,000 = **$0.12/分钟**
- **Turbo/Flash模型**: 22,000,000 credits (~22,000 min)
  - 1分钟价格: $1320 ÷ 22,000 = **$0.06/分钟**

紧接着我们需要确定三个关键指标：

1. **上游API的实际成本**（每秒/每分钟的费用）
2. **内部Token消耗单位**（便于计费和管理）
3. **内部Token价值**（便于计费和管理）

**成本计算（以Pro套餐为基准）：**

- **每秒成本**：$0.198 ÷ 60 = $0.0033/秒
- **Token换算**：1秒 = 100 tokens（自定义消耗单位）
- **Token成本**：$0.000033/token

### 完整套餐体系设计

在算出三个成本指标后，我们就可以设计完整的套餐体系。设计原则是：

1. **免费套餐**：足够体验核心功能，但不能满足长期使用
2. **付费套餐**：梯度定价，满足不同用户群体需求
3. **利润保障**：确保每个套餐都有合理的毛利率

**定价策略考虑：**

- **免费用户转化**：免费额度设置在用户"刚好体验到价值，但需要更多"的临界点
- **心理价格锚点**：最高价套餐让中等价格显得更合理
- **使用场景匹配**：轻度用户、重度用户、企业用户的不同需求

**免费用户**

上面我们定义了，1s = 100tokens。600个字符的文本TTS输出声音大概50秒，但具体需要多少秒免费用户才会转换，还是需要在真实用户使用后我们去统计转换的次数区间。

我们在最开始可以尽量给多一点给免费用户，5分钟也就是$1.98成本和30,000 tokens。

**月度订阅套餐**

- **轻量版 - $4.99/月**：100,000 tokens (17分钟)
  - 成本：$3.30，利润率：34%
- **标准版 - $14.99/月**：400,000 tokens (67分钟)
  - 成本：$13.20，利润率：12%
- **专业版 - $39.99/月**：1,200,000 tokens (200分钟)
  - 成本：$39.60，利润率：1%

**Token包 (一次性购买)**

- **体验包 - $2.99**：30,000 tokens (5分钟)
  - 成本：$0.99，利润率：67%
- **小包 - $9.99**：150,000 tokens (25分钟)
  - 成本：$4.95，利润率：50%
- **中包 - $24.99**：400,000 tokens (67分钟)
  - 成本：$13.20，利润率：47%
- **大包 - $59.99**：1,000,000 tokens (167分钟)
  - 成本：$33.00，利润率：45%

## 把基建与核心功能连起来

对于最核心的API调用和实现功能，这部分就不浪费篇幅了，大家可以自己看代码，因为它的本质就是看文档、组合API、创造出功能，确实没什么好讲的，核心功能也是大家在做自己项目要去考虑的事情。

而我们关注的应该是核心功能与基建的交互部分。

> 谅解一下，因为主要是给大家做演示，所以在核心功能的部分，并没有达到预想的生产级的面向创作者的体验（这个点子的项目我实在没时间去做了）。

### 定义Token的基础消耗

根据上面我们的定价，免费用户送30000Tokens，基础的消耗单位是每秒100Token。

```typescript
// config/token.ts
// Free user token configuration
export const FREE_USER_TOKENS = 30000 // 5 minutes, cost ~$1.98

export const TOKENS_PER_SECOND = 100 // Tokens per second
```

> 这部分的定义，大家可以根据自己的产品和功能进行定义。

### 交互部分的Token消耗

在API的调用Actions中，我们计算了当前TTS转换出声音的时长，来使用`updateUserTokenUsage`计算每次用户的消耗。

```typescript
// actions/design-voice.ts
export async function generateSpeech(text: string, voice: string) {
  const elevenlabs = new ElevenLabsClient()

  try {
    const audioStream = await elevenlabs.textToSpeech.streamWithTimestamps(voice, {
      text: text,
      modelId: 'eleven_flash_v2_5',
      outputFormat: 'mp3_44100_64'
    })

    const audioChunks: Buffer[] = []
    const alignments: ElevenLabs.CharacterAlignmentResponseModel[] = []

    for await (const item of audioStream) {
      if (item.audioBase64) {
        // 收集音频数据
        const audioBuffer = Buffer.from(item.audioBase64, 'base64')
        audioChunks.push(audioBuffer)
      }

      if (item.alignment) {
        // 收集时间戳信息
        alignments.push(item.alignment)
      }
    }

    let duration = 0
    if (alignments.length > 0) {
      // 找到最后一个字符的结束时间
      const lastAlignment = alignments[alignments.length - 1]
      if (lastAlignment.characterEndTimesSeconds && lastAlignment.characterEndTimesSeconds.length > 0) {
        // 获取最后一个字符的结束时间
        duration = lastAlignment.characterEndTimesSeconds[lastAlignment.characterEndTimesSeconds.length - 1]
      }
    }

    // 合并所有音频块
    const completeAudio = Buffer.concat(audioChunks)

    await updateUserTokenUsage({
      amount: Math.floor(duration) * TOKENS_PER_SECOND
    })

    return {
      audio: completeAudio.toString('base64'),
      alignments: alignments,
      duration
    }
  } catch (error) {
    throw new Error(`TTS generation failed: ${error}`)
  }
}
```

### Pricing和购买订阅送Token逻辑

发放用户Token、展示商品信息、关联三方支付的核心实际就是`Product`的产品表。

我们定义的产品表，在前面的支付部分也提到过，需要先录入商品信息（也就是虚拟商品订阅/购买）。这里面会有价格、以及需要给用户发放多少Token。

而前端对于虚拟商品的展示无非只是通过`id`去自定义文案（因为I18n的缘故）。可以参考`components/plan/plan-card.tsx`。

### 免费用户的Token赠送

实际上就是在Auth库，注册用户抛出钩子去增加用户的余额即可。

```typescript
events: {
  createUser: async ({ user }) => {
    await db.insert(userUsage).values({
      userId: user.id!,
      usedTokens: 0,
      totalTokens: FREE_USER_TOKENS
    })
  }
}
```

### 区分付费和非付费用户

在产品中，我们通常需要区别用户身份，付费/非付费用户/会员等。

我们只需要关注订单表的状态，只要订单付费成功了，就是付费用户。

```typescript
export async function getUserOrder() {
  const db = createDb()
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }
  const order = await db.query.orders.findFirst({
    where: eq(orders.id, session?.user?.id)
  })

  return order
}

// 前端的检查函数
const checkIsPaid = () => {
  if (!user) {
    setOpen(true)
    return false
  }
  if (!order || order.status !== 'completed') {
    toast('Please purchase a plan before accessing premium features.')
    router.push('/pricing')
    return false
  }
  return true
}
```

那如果要分订阅又该如何那？其实就是查看订阅表里这个用户是否在订阅期内即可。

## 结束

在下一章中，会针对SEO进一步优化项目的结构。
