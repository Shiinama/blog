# Next.js 在 Cloudflare 上的部署挑战

起源在于[第七章AI自动生成内容](https://articles.zsxq.com/id_zxblkmgnaf2w.html)解决`Page Functions`单请求不能长时间执行的问题。我尝试用`Cloudflare Queue`去处理大批量任务和长时间执行的情况，但发现任务没有消费和通知机制。

于是我就开始查找答案，最终的解法是采用`Cloudflare Workers`解决，而不是用`Cloudflare Pages`进行部署。整个基建的重构具体代码会在最简AI项目中的[第九章](https://articles.zsxq.com/id_v5pelubbff78.html)。

但要理解这个问题，得从起源`Serverless`架构说起了。

## Serverless 架构的演进与本质

Serverless 计算代表了云计算的一次范式转变，从根本上改变了应用程序的构建和部署方式。

### Serverless 的哲学

Serverless 的核心哲学可以概括为"关注业务逻辑，而非基础设施"。这种思想源于云计算发展的必然趋势：

1. **计算单元的演进**：从物理服务器 → 虚拟机 → 容器 → 函数
2. **抽象级别的提升**：从硬件管理 → 操作系统管理 → 运行时管理 → 纯代码逻辑
3. **资源分配模式的变革**：从静态分配 → 动态扩缩容 → 按需执行

这种演进反映了一个核心趋势：**计算资源的消费正在从"预留"模式转向"即用即付"模式**，类似于电力供应的公共设施模型。

### Serverless 的技术本质

从技术角度看，Serverless 架构建立在几个关键概念之上：

1. **事件驱动执行**：代码仅在响应特定事件时执行，而非持续运行
2. **执行环境的临时性**：计算环境可能在每次调用之间创建和销毁
3. **状态外部化**：应用状态必须存储在专门的持久化服务中
4. **分布式执行**：代码可以在地理分布的多个位置执行
5. **微粒度计费**：按实际执行的计算资源（毫秒级）计费

这些特性共同定义了 Serverless 的技术边界，也决定了其优势和局限性。

显然各大厂商都有 Serverless 的布局，但Cloudflare更便宜、更成熟。

## Cloudflare 的 Serverless

Cloudflare 提供了两种主要的 Serverless 部署方案：Workers 和 Pages。

### Cloudflare Workers

Workers 是 Cloudflare 的核心计算平台，具有完全不同的架构设计：

1. **架构特点**：

   - 基于 V8 引擎的隔离执行环境（Isolates）
   - 直接在 Cloudflare 的边缘网络节点上执行
   - 完整的请求-响应生命周期控制
   - 支持自定义路由和中间件模式

2. **技术能力**：

   - 更高的 CPU 和内存限额
   - 完整访问 Cloudflare 平台 API
   - 支持 WebAssembly 执行

3. **部署模型**：
   - 独立部署单元，不依赖构建系统
   - 支持增量部署和版本控制

### Cloudflare Pages、Pages Functions

Cloudflare Pages 最初设计为静态网站托管服务，后来通过 Pages Functions 扩展了服务端能力：

1. **架构特点**：

   - 基于构建系统（Build System）和静态资产分发
   - Pages Functions 作为附加功能集成到静态资产服务中
   - 使用 `_routes.json` 文件定义路由规则和函数映射

2. **技术限制**：

   - CPU 和内存资源受到更严格的限制
   - 无法直接访问某些底层 Cloudflare API
   - 函数冷启动时间较长

3. **部署模型**：
   - 每次部署需要完整构建过程
   - 函数与静态资产捆绑部署

Pages Functions 是在 Pages 平台上的一层抽象，它们在技术实现上与 Workers 有关联，但被施加了更多限制，并且集成到了 Pages 的构建和部署流程中。

#### Pages Functions 的技术本质

Pages Functions 是一种受限的 Workers 实现，它们共享底层的 V8 Isolates 技术，但有几个关键区别：

1. **执行环境**：Pages Functions 实际上是在 Cloudflare 的 Workers 基础设施上运行的特殊 Worker，但被包装在 Pages 的部署和路由系统中。

2. **生命周期管理**：

   - 与独立 Workers 不同，Pages Functions 的生命周期完全由 Pages 平台控制
   - 函数实例化和销毁与 Pages 应用的请求路由紧密耦合
   - 无法像独立 Workers 那样自定义启动和关闭行为

3. **运行时限制**：

   - 使用了 Workers 的子集 API，但施加了更严格的资源限制
   - 执行上下文被刻意限制，以确保与 Pages 的静态资产服务模型兼容
   - 无法使用某些高级 Workers 功能，如 Durable Objects

4. **构建时集成**：

   - Pages Functions 在构建过程中被识别和处理
   - 函数代码被编译并与路由规则一起打包
   - 部署时作为 Pages 项目的一部分一起推送

5. **实现**：
   - 使用 `functions` 目录中的文件自动生成路由映射
   - 每个函数文件被转换为独立的执行单元
   - 底层使用类似 Worker 的请求处理模型，但添加了额外的封装层

这种设计使 Pages Functions 成为一种"受管理的 Workers"，它们牺牲了灵活性和执行时间，换取了与静态网站托管的无缝集成和更简单的开发体验。

## Nextjs与Serverless

实际上与Nextjs适配程度最好的 Serverless 是 Vercel（毕竟就他们家开发的），能得到一个全火力版的Nextjs项目，还极大节省了开发成本。但是对于他们家在服务量上去后有多贵这件事我已经不止一次阐述过了。

下面我们对比两套工具的打包产物，可以帮我们更清晰理解上传到 Cloudflare 的产物，最终是如何提供服务的。

### @cloudflare/next-on-pages 构建产物

`@cloudflare/next-on-pages` 是将 `Next` 项目打包成 `Cloudflare pages` 的工具。它打包产物是直接抄的vercel的打包产物，将Next.js应用拆分为多个独立函数，每个路由对应一个.func目录，这是现在市面上最主流的做法。

```bash
.vercel/output/
├── functions/                  # 路由函数目录
│   ├── _not-found.func/        # 404页面函数
│   ├── index.func/             # 主页函数
│   │   ├── index.js            # 函数入口
│   │   └── index.js.map        # 源码映射
│   ├── index.rsc.func -> index.func  # RSC函数符号链接
│   ├── blog/[slug].func/       # 动态路由函数
│   └── api/auth/[...nextauth].func/  # API路由函数
├── static/                     # 静态资源
│   ├── _next/static/           # Next.js静态资源
│   │   ├── chunks/             # 代码分块
│   │   └── css/                # 样式文件
│   ├── _routes.json           # 路由配置
│   └── _worker.js             # Pages worker入口
```

其实这就意味着每个路由都是独立函数，需要单独冷启动，以及没办法使用nextjs自身的缓存管理策略。

### @openNextjs/cloudflare 构建产物

`@openNextjs/cloudflare` 采用单Worker架构，它的打包产物是生成worker的产物，用单一Worker处理所有路由，这一套的好处是能支持Nextjs的缓存策略了，并且可以使用全部Cloudflare生态的功能。

```bash
.open-next/
├── assets/                    # 静态资源
│   ├── _next/static/          # Next.js客户端资源
│   │   ├── chunks/            # 代码分块
│   │   └── css/               # 样式文件
├── cache/                     # 预渲染缓存
│   └── [BUILD_ID]/            # 按构建ID组织的缓存
│       ├── [locale]/          # 国际化路由缓存
│       ├── _not-found.cache   # 404页面缓存
│       └── robots.txt.cache   # 静态文件缓存
├── cloudflare/                # Cloudflare特定代码
│   ├── cache-assets-manifest.sql  # 资源清单SQL
│   └── init.js                # 初始化脚本
├── server-functions/          # 服务端函数
│   └── default/               # 默认服务端函数
│       ├── handler.mjs        # 请求处理器
│       ├── index.mjs          # 入口点
│       └── open-next.config.mjs  # 配置
└── worker.js                  # 主Worker入口
```

在部署完成之后，真正的就把 cloudflare 生态打开了，比如：定时器、队列内部消费机制、`Durable Objects`（Pages是不可用的）等。

它的功能和面板也比Page强大得多。

![](https://ik.imagekit.io/ixou4q6nu/metrics-pages.png?updatedAt=1747470951828)

![](https://ik.imagekit.io/ixou4q6nu/workers-logs.png?updatedAt=1747470951863)

> 题外话：我真的特别喜欢`Durable Objects`，它是`Cloudflare`提供的一种有状态的计算服务，本质就是创建一个长存的JavaScript对象实例，它非常强大和复杂。
>
> 它补全了整个 Serverless 很大的缺陷，可以作为后端服务的核心组件，处理那些需要状态一致性的功能，如用户会话、实时通知或数据同步等。甚至能够做文档多人协作、多人游戏这种高实时场景。
>
> 在第九章，它是用来处理Nextjs的缓存机制（ISR、Tag缓存验证）的组件之一。

## 结束

其实部署成`Pages`这件事，并不是不可用，我忍忍也就过了（毕竟后端功能没有那么重，就少个Next的缓存功能）。

但在这个项目不停的实践中，我其实发现这整套Cloudflare的能做到的架构上限和性能非常高（最复杂的高可用、高并发、全球化的部分被Cloudflare承担了），并且两套部署方案的相似度极高，复杂度相差不算太大，因此要做就做到最好。
