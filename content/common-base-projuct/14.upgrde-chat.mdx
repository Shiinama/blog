# 三方支付的接入

在上一章讲了有关支付的底层表结构设计，那么这一章我们就来接入三方支付。

在海外的支付收款生态中，Paypal是一个绕不开很重要的部分，我通常打款也是两种方式一种是Credit Card，一种是Paypal。相对各种复杂的支付渠道来说，Paypal的个人号的门槛是最低的，可以直接收钱+循环扣款的，在注册PayPal后我们只需要找一个支付网关将其接入。

那么在进一步支付网关中门槛比较低的是Upgrade.chat，它什么都不需要，只需要你有个Paypal个人户，绑定它的网关就可以支付了。

> 并且因为相当于是Paypal来进行循环扣款，它的订阅扣款失败率是很低的。

[本章Tag](https://github.com/Shiinama/next-cloudflare-template/tree/v10.1.0)

## Upgrade.chat API与配置

在注册绑定Paypal后，先创建商品，我创建了2个One-Time和一个Subscription的商品。

![](https://ik.imagekit.io/ixou4q6nu/product-upgrade.png?updatedAt=1752399540942)

紧接着添加商品的嵌入代码，其实在这一步已经可以付钱了，点开这个链接会跳出他们的支付方式，紧接着点PayPal来进行支付

![](https://ik.imagekit.io/ixou4q6nu/embed-payment.png?updatedAt=1752399022552)

但我们要进行开发得先创建一个API Key

![](https://ik.imagekit.io/ixou4q6nu/create-api-key.png?updatedAt=1752398458574)

紧接着看看他们提供了哪些API，大部分都是很常规的GET查询类接口（可能他们觉得太简单了，我也没找到详细解释的API）：

![](https://ik.imagekit.io/ixou4q6nu/payment-easy.png?updatedAt=1752398458587)

接下来我们创建一个Webhook来接收支付成功的通知。

![](https://ik.imagekit.io/ixou4q6nu/api-webhook.png?updatedAt=1752398727678)

## 完成业务逻辑

### 前端

在`layout`中添加他们的`Script`

```typescript
<head>
  <script src="https://upgrade.chat/embed/embed.js" defer />
</head>
```

在`pricing`页面中添加2个刚刚添加的商品支付嵌入代码（他的本质其实嵌入Iframe）

```typescript
'use client'

export default function PricingPage() {
  return (
    <div className="flex gap-4">
      <div
        className="h-96 w-80"
        data-upgrade-chat-embed="2d7ea31d-bcb0-4062-b476-327bd6d7a8d6"
        data-upgrade-chat-products="be66b10a-69dd-42f0-bf0d-97083b46344e"
        data-upgrade-chat-baseurl="https://upgrade.chat"
      />
      <div
        className="h-96 w-80"
        data-upgrade-chat-embed="2d7ea31d-bcb0-4062-b476-327bd6d7a8d6"
        data-upgrade-chat-products="62312764-a2ce-4e71-b585-0eefc55ec27d"
        data-upgrade-chat-baseurl="https://upgrade.chat"
      />
      <div
        data-upgrade-chat-embed="2d7ea31d-bcb0-4062-b476-327bd6d7a8d6"
        data-upgrade-chat-products="3eea989a-9e7a-454f-bcb6-909fd92b8759"
        data-upgrade-chat-baseurl="https://upgrade.chat"
      />
    </div>
  )
}
```

在页面上的展示

![](https://ik.imagekit.io/ixou4q6nu/embed-success.png?updatedAt=1752399689115)

但其实它的本质是`Iframe`,我在后续改良了一下。

```typescript
'use client'

function UpgradeChat({ products }: { products: string }) {
  const toUpgradeChat = () => {
    let src = `https://upgrade.chat/view-embed/2d7ea31d-bcb0-4062-b476-327bd6d7a8d6`
    const queryParams = [`embedder_url=${encodeURIComponent(window.location.href)}`]
    if (products) {
      for (const product of products.split(',')) {
        queryParams.push(`productId=${product}`)
      }
    }
    if (queryParams.length > 0) {
      src += `?${queryParams.join('&')}`
    }

    const width = 350
    const height = 450

    const left = window.screen.width / 2 - width / 2
    const top = window.screen.height / 2 - height / 2

    window.open(src, '_blank', `width=${width},height=${height},top=${top},left=${left}`)
  }

  return (
    <button
      onClick={toUpgradeChat}
      className="bg-primary text-primary-foreground hover:bg-primary/90 mt-6 w-full rounded-full px-4 py-3 font-bold transition duration-200"
    >
      PayPal
    </button>
  )
}

export default UpgradeChat
```

### 后端

完成前端之后，我们思考一下正常的支付流程是和当前提供的API条件是怎么样的。可以想象得到，应该是 Webhook通知 -> 接收到支付成功的通知 -> 找到对应的 Product -> 添加订单 -> 改变订单状态 -> 添加余额。

路由的访问地址要跟在`upgrade.chat`添加的回调路由一致，也就是在`app/api/upgrade-chat/associate`。

因为这个支付方式不能进行单号与他们系统关联，就只能通过邮箱的方式进行查找，所以需要要求用户一定是登录并且存在邮箱的。

> 因为这里必须绑定邮箱的问题，在实际业务中，需要在前后置进行提醒和补救，前置就是提醒用户一定要用登录平台绑定的邮箱在支付的的时候，后置就是当用户已经犯错，需要去进行人为补单，或者通过返回支付兑换码让用户兑换属于他的套餐和权益等方式。
> 这没有办法，门槛低的支付，限制也会存在非常多，有条件的（美国或香港公司3000rmb左右代开）同学直接走stipe、信用卡（我可以给大家推几个比较好的厂商）、paypal等大支付。

代码中的就是在上一章中的提到的创建订单 -> 改变订单状态 -> 添加余额。这看起来是在一个请求里完全，实际上也是因为支付方式只有成功的通知，但这个架构是通用的，因为比较大的支付可以把创建和支付成功分开。

```typescript
import { NextRequest, NextResponse } from 'next/server'

import { createOrder, findUserProfileByEmail, handlePaymentSuccess } from '@/actions/payment/orders'
import { generateAuthorizationTokens, getEventDetail, verifyWebhookEvent } from '@/lib/upgrade-chat-client'

export async function POST(request: NextRequest) {
  const body: {
    id?: string
    webhook_id?: string
  } = await request.json()

  const { id: eventId, webhook_id: webhookId } = body

  if (!eventId || !webhookId) {
    return NextResponse.json({ error: 'event_id is require!' }, { status: 400 })
  }

  const token = await generateAuthorizationTokens()

  if (token) {
    const valid = await verifyWebhookEvent(eventId, token.access_token)
    if (valid) {
      const { data } = await getEventDetail(eventId, token.access_token)
      const body = data.body
      body.user.email = '2072738187yu@gmail.com'

      if (body.user.email) {
        const user = await findUserProfileByEmail(body.user.email)

        if (user) {
          switch (data.type) {
            case 'order.created':
            case 'order.updated':
              const order = await createOrder({
                productId: body.order_items[0].product.uuid,
                paymentMethod: 'upgrade.chat',
                userId: user.id
              })

              if (!order) {
                console.error('Create Order Failed:', body.uuid)
                return NextResponse.json({ error: 'Create Order Failed!' }, { status: 500 })
              }

              if (order.status === 'completed') {
                console.error('Order already completed:', body.uuid)
                return NextResponse.json({ error: 'Order already completed!' }, { status: 500 })
              }
              await handlePaymentSuccess({
                order,
                paymentIntentId: body.uuid,
                metadata: JSON.stringify(body)
              })
              return NextResponse.json({ message: 'Order Created!' }, { status: 200 })

            case 'order.deleted':
              console.error('Order deleted:', body.uuid)
              break

            default:
              console.error('Unknown event type:', data.type)
              break
          }
        }
      }

      return NextResponse.json({ message: 'User not found!' }, { status: 404 })
    }
  }
}
```

> 在里面的函数和调用，已经在上一章提到过了，大多数支付都在API层面比较简单。难的还是在把支付谈下来、以及处理支付退款等（会有一张详细讲整个支付行业的拆分和对于业务的影响）。

另外一个值得注意的点是在于：我们依赖的是自己的商品系统，而不是他们的，实际上发放什么商品是由我们自己决定的，我们只是需要支付方式收钱。所以需要在`Product`表中添加对应的商品。

## 结束

终于，我们把基建的要素完成了，我其实现在也比较烦写代码类的文章，可能是因为本身一个代码，我业务里写过一遍、写模版又写一遍、写文章再写一篇，实在是折磨了。

AI最简应用系列还有最后两章，是优化整个基建，在此之后，会写一些更有意义和普适的东西，就是那种即使你用不到，你跟别人讲这件事情，他也会觉得：“哇，这东西你怎么知道的，真有用”

而不是代码这种只要一深入讲细节，大家都会觉得很无聊的事情了。
