# 重构为worker

[章节Tag](https://github.com/Shiinama/next-cloudflare-template/tree/v7.0.0)

## 基础配置流程

将Next.js应用重构为Cloudflare Worker需要一些下面的配置和操作，但其实代码已经写好了在[Tag](https://github.com/Shiinama/next-cloudflare-template/tree/v7.0.0)里，只是讲一下过程。

### 下载依赖、修改配置文件、添加脚本

首先执行`pnpm add @opennextjs/cloudflare`，紧接着完成`wrangler.jsonc`的配置，这部分配置会在上传到`Cloudflare`的时候自动完成绑定。

重构的配置是这些：

```json
{
  "$schema": "node_modules/wrangler/config-schema.json",
  "name": "cloudflare-template",
  "main": ".open-next/worker.js",
  "compatibility_date": "2025-04-22",
  "compatibility_flags": ["nodejs_compat", "global_fetch_strictly_public"],
  "observability": {
    "logs": {
      "enabled": true
    }
  },
  "assets": {
    "directory": ".open-next/assets",
    "binding": "ASSETS"
  },
  "ai": {
    "binding": "AI"
  },
  "r2_buckets": [
    {
      "bucket_name": "demo",
      "binding": "NEXT_INC_CACHE_R2_BUCKET"
    }
  ],
  "durable_objects": {
    "bindings": [
      {
        "name": "NEXT_CACHE_DO_QUEUE",
        "class_name": "DOQueueHandler"
      },
      {
        "name": "NEXT_TAG_CACHE_DO_SHARDED",
        "class_name": "DOShardedTagCache"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["DOQueueHandler", "DOShardedTagCache"]
    }
  ],
  "services": [
    {
      "binding": "WORKER_SELF_REFERENCE",
      "service": "cloudflare-template"
    }
  ]
}
```

- `$schema`: 指向配置文件的JSON Schema，提供编辑器自动完成功能。
- `name`: Worker的名称，这将是你的 Worker 在 Cloudflare 控制台中显示的名称，也是访问 Worker 时使用的子域名的一部分。
- `main`: Worker的入口文件，对于 OpenNext 项目，这通常是构建后生成的 .open-next/worker.js 文件。
- `compatibility_date`: 指定Worker运行时版本的日期，Cloudflare 会根据这个日期确定使用哪个版本的 Workers 运行时。
- `compatibility_flags`: 启用Node.js兼容层和公共URL请求功能

- `observability`: 启用日志记录，方便在Cloudflare控制台查看运行日志

- `assets`: 配置静态资源

  - `directory`: 静态资源目录
  - `binding`: 在Worker中访问资源的变量名，也是我们在环境中写的变量名。

- `ai`: 绑定Cloudflare AI服务，可用于文本生成、图像处理等AI功能

- `r2_buckets`: 配置R2存储桶

  - `bucket_name`: 存储桶名称
  - `binding`: 创建一个名为 `NEXT_INC_CACHE_R2_BUCKET` 的绑定，用于 Next.js 的增量缓存

- `durable_objects`: 配置有状态存储服务

  - `NEXT_CACHE_DO_QUEUE`: 处理Next.js缓存队列
  - `NEXT_TAG_CACHE_DO_SHARDED`: 处理Next.js标签缓存

- `migrations`: 为Durable Objects创建SQLite数据库

- `services`: 这个配置允许 Worker 引用自己，这在某些需要 Worker 调用自身的场景中很有用，比如实现某些递归操作或分布式处理。

在package.json中添加以下脚本，简化开发和部署流程：

```json
"scripts": {
  "preview": "opennextjs-cloudflare build && opennextjs-cloudflare preview",
  "deploy": "opennextjs-cloudflare build && opennextjs-cloudflare deploy",
  "upload": "opennextjs-cloudflare build && opennextjs-cloudflare upload",
  "cf-typegen": "wrangler types --env-interface CloudflareEnv cloudflare-env.d.ts"
}
```

这些命令分别用于：

- preview: 构建应用并在本地Workers运行时预览，让你通过单个命令快速预览应用
- deploy: 构建并立即部署到Cloudflare
- upload: 构建并上传新版本到Cloudflare
- cf-typegen: 在项目根目录生成包含env类型的cloudflare-env.d.ts文件

紧接着跑一下`pnpm cf-typegen`自动生成项目的类型，这个命令在每次新增绑定的服务的时候都可以调用一下，用于生成类型，便于语法提示。

### 配置文件设置

虽然在构建过程中`@opennextjs/cloudflare`会自动创建配置文件（如果不存在），但你也可以自己创建。除了上面的`wrangler.jsonc`配置外，还需要创建一个`open-next.config.ts`文件：

```typescript
import { defineCloudflareConfig } from '@opennextjs/cloudflare'
import r2IncrementalCache from '@opennextjs/cloudflare/overrides/incremental-cache/r2-incremental-cache'
import doQueue from '@opennextjs/cloudflare/overrides/queue/do-queue'
import doShardedTagCache from '@opennextjs/cloudflare/overrides/tag-cache/do-sharded-tag-cache'

export default defineCloudflareConfig({
  incrementalCache: r2IncrementalCache,
  tagCache: doShardedTagCache({ baseShardSize: 12, regionalCache: true }),
  queue: doQueue
})
```

这个配置是启用了Cloudflare的缓存以支持Nextjs的缓存功能。

### 静态资源缓存优化

创建`public/_headers`文件，添加缓存控制：

```
/_next/static/*
  Cache-Control: public,max-age=31536000,immutable
```

这能确保静态资源得到适当缓存，提高加载速度。更多信息可以参考静态资源缓存文档。

### 修改Next.js配置

更新`next.config.ts`文件，添加Cloudflare开发集成：

```typescript
import { initOpenNextCloudflareForDev } from '@opennextjs/cloudflare'
import { NextConfig } from 'next'
import createNextIntlPlugin from 'next-intl/plugin'

initOpenNextCloudflareForDev()

const nextConfig: NextConfig = {
  devIndicators: false,
  experimental: {
    staleTimes: {
      dynamic: 3600,
      static: 3600
    }
  }
}

const withNextIntl = createNextIntlPlugin({
  experimental: {
    createMessagesDeclaration: './messages/en.json'
  }
})
export default withNextIntl(nextConfig)
```

添加`initOpenNextCloudflareForDev()`调用后，你可以在本地开发过程中访问Cloudflare绑定的本地版本，如绑定文档中所述。

我们在第3步中还添加了`npm run preview`命令，它允许你在Workers运行时而不是Node.js中快速预览应用。这使你能够在与部署到Cloudflare时相同的运行时中测试更改。

### 替换移除代码

- 移除任何`export const runtime = "edge";`声明，因为@opennextjs/cloudflare不支持edge运行时。
- 移除`@cloudflare/next-on-pages`这个包。
- 用`@opennextjs/cloudflare`中的`getCloudflareContext`替换`@cloudflare/next-on-pages`中的`getRequestContext`

### 部署

- 通过Push，CL会自己完成部署。
- `pnpm deploy:c`会读取本地的`.env`文件进行部署。

## Cloudflare如何实现Nextjs的缓存

> 接下来讲一下原理源码，这部分的内容是属于可看可不看的，这是满足我对技术的好奇心以及对使用一门新技术的安全感。

[官方的简单文档](https://opennext.js.org/cloudflare/caching)

Next.js提供了多种通过缓存路由和网络请求来提高应用性能的方法。应用程序会尝试在构建时预渲染并缓存尽可能多的数据，以减少向用户提供响应时所需的工作量。

缓存数据通过重新验证进行更新，可以是定期的或按需的：

- **基于时间的重新验证**：在应用程序指定的重新验证延迟过期后更新缓存数据
- **按需重新验证**：允许通过特定标签（通过`revalidateTag`）或在给定路径（通过`revalidatePath`）使缓存条目无效。

`@opennextjs/cloudflare`的缓存支持依赖于3个组件：

1. **增量缓存（Incremental Cache）**：存储缓存数据
2. **队列（Queue）**：同步和去重基于时间的重新验证
3. **标签缓存（Tag Cache）**：用于通过`revalidateTag`和`revalidatePath`进行按需重新验证

### 缓存实现

而对于这三者的实现我采用的是：

- **增量缓存**：使用R2存储数据，[源码地址](https://github1s.com/opennextjs/opennextjs-cloudflare/blob/main/packages/cloudflare/src/api/overrides/incremental-cache/r2-incremental-cache.ts)
- **队列**：使用由Durable Objects实现的时间验证队列，[源码地址](https://github1s.com/opennextjs/opennextjs-cloudflare/blob/main/packages/cloudflare/src/api/durable-objects/queue.ts)
- **标签缓存**：使用由Durable Objects实现的缓存验证系统，[源码地址](https://github1s.com/opennextjs/opennextjs-cloudflare/blob/main/packages/cloudflare/src/api/durable-objects/sharded-tag-cache.ts)

### R2增量缓存实现原理

R2增量缓存是Next.js在Cloudflare环境中存储缓存数据的主要机制。它利用Cloudflare的R2对象存储服务，提供高性能、低成本的数据存储解决方案。

R2增量缓存实现了标准的Next.js增量缓存接口，包括`get`、`set`和`delete`方法，使其能够无缝集成到Next.js的缓存系统中。

核心实现代码如下：

```typescript
class R2IncrementalCache implements IncrementalCache {
  readonly name = NAME

  async get<CacheType extends CacheEntryType = 'cache'>(
    key: string,
    cacheType?: CacheType
  ): Promise<WithLastModified<CacheValue<CacheType>> | null> {
    const r2 = getCloudflareContext().env[BINDING_NAME]
    if (!r2) throw new IgnorableError('No R2 bucket')

    debugCache(`Get ${key}`)

    try {
      const r2Object = await r2.get(this.getR2Key(key, cacheType))
      if (!r2Object) return null

      return {
        value: await r2Object.json(),
        lastModified: r2Object.uploaded.getTime()
      }
    } catch (e) {
      error('Failed to get from cache', e)
      return null
    }
  }

  async set<CacheType extends CacheEntryType = 'cache'>(
    key: string,
    value: CacheValue<CacheType>,
    cacheType?: CacheType
  ): Promise<void> {
    const r2 = getCloudflareContext().env[BINDING_NAME]
    if (!r2) throw new IgnorableError('No R2 bucket')

    debugCache(`Set ${key}`)

    try {
      await r2.put(this.getR2Key(key, cacheType), JSON.stringify(value))
    } catch (e) {
      error('Failed to set to cache', e)
    }
  }

  async delete(key: string): Promise<void> {
    const r2 = getCloudflareContext().env[BINDING_NAME]
    if (!r2) throw new IgnorableError('No R2 bucket')

    debugCache(`Delete ${key}`)

    try {
      await r2.delete(this.getR2Key(key))
    } catch (e) {
      error('Failed to delete from cache', e)
    }
  }

  protected getR2Key(key: string, cacheType?: CacheEntryType): string {
    return computeCacheKey(key, {
      prefix: getCloudflareContext().env[PREFIX_ENV_NAME],
      buildId: process.env.NEXT_BUILD_ID,
      cacheType
    })
  }
}
```

R2增量缓存的主要特点包括：

1. **简单高效**：直接使用R2的API进行读写操作，实现简单而高效。

2. **错误处理**：包含全面的错误处理机制，确保缓存操作失败不会导致应用崩溃。

3. **键生成策略**：使用`computeCacheKey`函数生成唯一的缓存键，考虑了前缀、构建ID和缓存类型。

4. **元数据保存**：在缓存值中保存`lastModified`时间戳，用于后续的缓存验证。

5. **环境变量配置**：通过环境变量`NEXT_INC_CACHE_R2_BUCKET`和`NEXT_INC_CACHE_R2_PREFIX`进行配置，提供灵活性。

R2增量缓存是整个缓存系统的基础，它提供了持久化存储层，而队列和标签缓存则负责管理缓存的重新验证策略。

### Durable Objects时间队列实现原理

`DOQueueHandler`是实现的类名，可以约定俗成的调用，在json配置文件中也写了，它用于处理Next.js中基于时间的重新验证。它提供了以下关键功能：

1. **去重处理**：通过`ongoingRevalidations`映射表跟踪正在进行的重新验证，确保相同路由的重新验证请求不会重复执行。

2. **失败状态管理**：使用`routeInFailedState`映射表跟踪失败的重新验证，实现指数退避重试机制。

3. **持久化存储**：利用Durable Objects的SQLite存储，保存失败状态和同步信息，确保即使在Worker重启后也能恢复状态。

4. **并发控制**：通过`maxRevalidations`限制同时进行的重新验证数量，防止系统过载。

核心实现代码如下：

```typescript
async executeRevalidation(msg: QueueMessage) {
  try {
    debug(`Revalidating ${msg.MessageBody.host}${msg.MessageBody.url}`);

    // 从消息体中提取主机名和URL路径
    const {
      MessageBody: { host, url },
    } = msg;

    // 根据主机名确定使用的协议（本地开发用http，生产环境用https）
    const protocol = host.includes("localhost") ? "http" : "https";

    // 发送重新验证请求到目标URL
    // 使用HEAD方法减少数据传输，因为我们只需触发重新验证而不需要实际内容
    // 添加特殊的头部来标识这是一个重新验证请求
    // x-prerender-revalidate: 包含预览模式ID，用于授权重新验证操作
    // x-isr: 标记这是一个增量静态再生成(ISR)请求
    // 设置超时信号，防止请求无限期挂起
    const response = await this.service.fetch(`${protocol}://${host}${url}`, {
      method: "HEAD",
      headers: {
        "x-prerender-revalidate": process.env.__NEXT_PREVIEW_MODE_ID!,
        "x-isr": "1",
      },
      signal: AbortSignal.timeout(this.revalidationTimeout),
    });

    // 这里原本有处理响应状态的代码，根据响应状态码执行不同操作
    // 例如检查是否成功(2xx)，是否需要重定向(3xx)，或者处理错误(4xx/5xx)

    // 如果重新验证成功，更新SQLite数据库中的同步记录
    // 记录最后一次成功重新验证的时间戳和当前构建ID
    // unixepoch()是SQLite函数，返回当前的UNIX时间戳
    if (!this.disableSQLite) {
      this.sql.exec(
        "INSERT OR REPLACE INTO sync (id, lastSuccess, buildId) VALUES (?, unixepoch(), ?)",
        `${host}${url}`,  // 使用"host+url"作为唯一标识符
        process.env.__NEXT_BUILD_ID  // 当前应用的构建ID，用于版本跟踪
      );
    }

    // 从失败状态映射中移除此路由，因为重新验证已成功
    this.routeInFailedState.delete(msg.MessageDeduplicationId);
  } catch (e) {
    if (!isOpenNextError(e)) {
      await this.addToFailedState(msg);
    }
    error(e);
  } finally {
    // 无论成功还是失败，都从正在进行的重新验证映射中移除此任务
    // 这样可以释放资源并允许将来再次重新验证同一路由
    this.ongoingRevalidations.delete(msg.MessageDeduplicationId);
  }
}
```

队列实现还包含重试机制，使用指数退避算法处理失败的重新验证：

```typescript
async addToFailedState(msg: QueueMessage) {
  // 打印调试信息，表明正在将路由添加到失败状态
  debug(`Adding ${msg.MessageBody.host}${msg.MessageBody.url} to the failed state`);

  // 检查此路由是否已经在失败状态映射中
  const existingFailedState = this.routeInFailedState.get(msg.MessageDeduplicationId);

  let updatedFailedState: FailedState;

  if (existingFailedState) {
    // 如果路由已经在失败状态中，检查是否已达到最大重试次数
    if (existingFailedState.retryCount >= this.maxRetries) {
      // 达到最大重试次数，从失败状态映射中移除，不再尝试重新验证
      this.routeInFailedState.delete(msg.MessageDeduplicationId);
      return;
    }

    // 使用指数退避算法计算下次重试时间
    // 公式: 当前时间 + (2^重试次数) * 基础重试间隔
    // 这确保每次重试的间隔呈指数增长，减轻系统负担
    const nextAlarmMs =
      Date.now() + Math.pow(2, existingFailedState.retryCount + 1) * this.revalidationRetryInterval;

    // 更新失败状态，增加重试计数并设置下次重试时间
    updatedFailedState = {
      ...existingFailedState,
      retryCount: existingFailedState.retryCount + 1,
      nextAlarmMs,
    };
  } else {
    // 如果这是首次失败，创建新的失败状态记录
    // 设置初始重试计数为1，并安排在2秒后进行首次重试
    updatedFailedState = {
      msg,                           // 保存原始消息以便重试时使用
      retryCount: 1,                 // 初始重试计数
      nextAlarmMs: Date.now() + 2_000, // 2秒后重试
    };
  }

  // 将更新后的失败状态保存到内存映射中，用于快速访问
  this.routeInFailedState.set(msg.MessageDeduplicationId, updatedFailedState);

  // 如果启用了SQLite存储，将失败状态持久化到数据库
  // 这确保即使Worker重启，失败状态也不会丢失
  if (!this.disableSQLite) {
    this.sql.exec(
      "INSERT OR REPLACE INTO failed_state (id, data, buildId) VALUES (?, ?, ?)",
      msg.MessageDeduplicationId,                    // 使用消息ID作为主键
      JSON.stringify(updatedFailedState),            // 将整个失败状态对象序列化为JSON
      process.env.__NEXT_BUILD_ID                    // 记录当前构建ID，用于版本跟踪
    );
  }

  // 添加闹钟，确保在适当的时间触发重试
  // addAlarm方法会设置一个系统闹钟，在最早需要重试的时间点唤醒Worker
  await this.addAlarm();
}
```

这是添加闹钟的方法，一堆判断是为了只在需要的时候才设置。

```typescript
async addAlarm() {
  // 检查是否已经存在闹钟
  // allowConcurrency: false 确保在获取闹钟状态时不会有并发操作
  const existingAlarm = await this.ctx.storage.getAlarm({ allowConcurrency: false });

  // 如果已经设置了闹钟，则不需要再设置
  if (existingAlarm) return;

  // 如果没有失败状态的路由需要重试，则不需要设置闹钟
  if (this.routeInFailedState.size === 0) return;

  // 找出所有失败状态中最早需要重试的时间
  // 通过遍历所有失败状态，获取它们的nextAlarmMs值，然后找出最小值
  let nextAlarmToSetup = Math.min(
    ...Array.from(this.routeInFailedState.values()).map(({ nextAlarmMs }) => nextAlarmMs)
  );

  // 确保闹钟不会设置在过去的时间点
  // 如果计算出的时间已经过去，则设置为当前时间加上基础重试间隔
  if (nextAlarmToSetup < Date.now()) {
    // 我们不希望设置一个过去的闹钟时间
    nextAlarmToSetup = Date.now() + this.revalidationRetryInterval;
  }

  // 设置闹钟，当闹钟触发时，Durable Object的alarm()方法会被调用
  // 这将导致系统在指定时间点唤醒Worker，执行重试逻辑
  await this.ctx.storage.setAlarm(nextAlarmToSetup);
}
```

`alarm` 是 Cloudflare Durable Objects 中的一个约定俗成的方法名。在 Durable Objects 中，当你通过 `storage.setAlarm()` 设置了一个闹钟，当闹钟时间到达时，Cloudflare 运行时会自动调用该 Durable Object 实例的 `alarm()` 方法。

> 这是 Cloudflare Durable Objects API 的一个特殊约定，类似于生命周期钩子函数。通过重写（override）这个方法，我们可以定义当闹钟触发时应该执行的逻辑。

```typescript
override async alarm() {
  // 获取当前时间戳，用于比较哪些事件需要重试
  const currentDateTime = Date.now();

  // 查找所有计划在未来重试的事件（nextAlarmMs > 当前时间）
  // 按照重试时间排序，获取最早需要重试的事件
  // 这里使用filter筛选出未来的事件，然后用sort按时间排序，取第一个
  const nextEventToRetry = Array.from(this.routeInFailedState.values())
    .filter(({ nextAlarmMs }) => nextAlarmMs > currentDateTime)
    .sort(({ nextAlarmMs: a }, { nextAlarmMs: b }) => a - b)[0];

  // 查找所有已过期的事件（nextAlarmMs <= 当前时间）
  // 这些事件应该立即重试，因为它们的计划重试时间已经到了或已经过去
  const expiredEvents = Array.from(this.routeInFailedState.values()).filter(
    ({ nextAlarmMs }) => nextAlarmMs <= currentDateTime
  );

  // 合并需要重试的事件列表
  // 如果有未来的事件，将其与过期事件合并；否则只处理过期事件
  // 这确保了我们既处理紧急的过期事件，也安排了下一个计划中的事件
  const allEventsToRetry = nextEventToRetry ? [nextEventToRetry, ...expiredEvents] : expiredEvents;

  // 遍历所有需要重试的事件，逐一执行重新验证
  for (const event of allEventsToRetry) {
    // 打印调试信息，显示正在重试的URL
    debug(`Retrying revalidation for ${event.msg.MessageBody.host}${event.msg.MessageBody.url}`);

    // 执行重新验证操作
    // executeRevalidation方法会处理实际的重新验证请求，并更新失败状态
    await this.executeRevalidation(event.msg);
  }
}
```

### 标签缓存实现原理

缓存标签系统也是由Durable Objects实现，它要简单的多，用于处理按需重新验证。同理`DOShardedTagCache`同名绑定的类名。

```typescript
import { DurableObject } from 'cloudflare:workers'

export class DOShardedTagCache extends DurableObject<CloudflareEnv> {
  // 声明SQL存储实例，用于与SQLite数据库交互
  sql: SqlStorage

  constructor(state: DurableObjectState, env: CloudflareEnv) {
    // 调用父类构造函数，传入状态和环境变量
    super(state, env)

    // 获取SQLite存储接口
    this.sql = state.storage.sql

    // 阻塞并发操作，确保数据库表创建完成后再处理其他请求
    state.blockConcurrencyWhile(async () => {
      // 创建revalidations表，如果不存在的话
      // 表结构：tag(文本，主键)，revalidatedAt(整数，表示重新验证的时间戳)
      this.sql.exec(`CREATE TABLE IF NOT EXISTS revalidations (tag TEXT PRIMARY KEY, revalidatedAt INTEGER)`)
    })
  }

  // 获取一组标签中最近的重新验证时间戳
  async getLastRevalidated(tags: string[]): Promise<number> {
    try {
      // 构建动态SQL查询，查找指定标签中最大的revalidatedAt值
      // 使用参数化查询防止SQL注入
      const result = this.sql
        .exec(
          // 动态生成IN子句，每个标签对应一个问号占位符
          `SELECT MAX(revalidatedAt) AS time FROM revalidations WHERE tag IN (${tags.map(() => '?').join(', ')})`,
          ...tags // 展开标签数组作为SQL参数
        )
        .toArray() // 将结果转换为数组

      // 如果没有结果，返回0（表示从未重新验证过）
      if (result.length === 0) return 0

      // 返回查询结果中的time字段（最大时间戳）
      return result[0]?.time as number
    } catch (e) {
      // 记录错误但不中断执行
      console.error(e)
      // 出错时返回0，避免应用崩溃
      return 0
    }
  }

  // 检查标签是否在指定时间后被重新验证过
  async hasBeenRevalidated(tags: string[], lastModified?: number): Promise<boolean> {
    // 执行SQL查询，检查是否有任何标签的revalidatedAt大于lastModified
    // LIMIT 1优化：只要找到一个符合条件的记录就返回
    return (
      this.sql
        .exec(
          `SELECT 1 FROM revalidations WHERE tag IN (${tags.map(() => '?').join(', ')}) AND revalidatedAt > ? LIMIT 1`,
          ...tags, // 标签参数
          lastModified ?? Date.now() // 如果未提供lastModified，则使用当前时间
        )
        .toArray().length > 0 // 如果结果数组长度大于0，表示找到了符合条件的记录
    )
  }

  // 更新多个标签的重新验证时间戳
  async writeTags(tags: string[], lastModified: number): Promise<void> {
    // 遍历每个标签，分别更新其重新验证时间戳
    tags.forEach((tag) => {
      // 使用INSERT OR REPLACE语法，如果标签已存在则更新，不存在则插入
      this.sql.exec(
        `INSERT OR REPLACE INTO revalidations (tag, revalidatedAt) VALUES (?, ?)`,
        tag, // 标签名
        lastModified // 重新验证时间戳
      )
    })
  }
}
```

### 完整缓存系统的工作流程

在Cloudflare环境中，Next.js的缓存系统通过以下流程工作：

1. **请求处理**：当请求到达时，首先检查R2增量缓存中是否有可用的缓存数据。

2. **缓存命中**：如果找到缓存数据，检查是否需要重新验证：

   - 检查`ShardedDOTagCache`中的标签是否已被重新验证
   - 检查缓存条目的重新验证时间是否已过期

3. **重新验证触发**：

   - 对于基于时间的重新验证，将消息发送到`DOQueueHandler`队列
   - 对于按需重新验证，通过`ShardedDOTagCache`更新标签状态

4. **缓存更新**：重新验证完成后，更新R2中的缓存数据和相关元数据

这种架构提供了高效、可靠的缓存系统，能够处理大量请求并确保内容的及时更新。

## 吐槽

这一章写得累死我了，大家别学我，应用就应该能跑就行，没遇到问题就别浪费时间去看有的没的。

事实又证明了另外一个道理，市面上主流的东西（比如Cloudflare Page架构）不一定就是最好的，它在做这种全栈应用的时候受限太大了。

下一章就主要讲实现Token机制，Token用于限制、统计用户对于工具功能的使用情况，是一个万金油基础功能。完成后，就集齐要素了，之后我录个视频过一遍从0到开发一个广告站类营收工具站的时间。
