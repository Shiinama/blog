# 使用AI自动生成内容

上一节讲了登录，这一节就讲AI自动生成文章内容，需要生成文章内容的核心原因：页面太少在Google没流量，需要长期的内容更新才有流量。

[本章Tag](https://github.com/Shiinama/next-cloudflare-template/tree/v4.0.1)

## 创建表结构完成后端接口

这一段表结构添加到`lib/db/schema.ts`，用于描述发布的文章。

```typescript
export const posts = sqliteTable('posts', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  slug: text('slug').notNull().unique(),
  title: text('title').notNull(),
  excerpt: text('excerpt').notNull(),
  content: text('content').notNull(),
  locale: text('locale').notNull().default('en'),
  publishedAt: integer('published_at', { mode: 'timestamp_ms' }),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull()
})
```

上面定义的表结构包含以下字段：

- id: 文章的唯一标识符，使用UUID自动生成
- slug: 文章的URL，用于在网址中显示，必须唯一
- title: 文章标题，用于MetaTitle
- excerpt: 文章摘要，用于MetaDescription
- content: 文章的完整内容，存储为Markdown
- locale: 文章的语言，默认为英文('en')，、
- publishedAt: 文章发布时间，可为null表示未发布的草稿
- createdAt: 文章创建时间，自动设置为当前时间戳
- updatedAt: 文章最后更新时间，自动设置为当前时间戳

> 值得关注的点是关于语言的设置，显然文章是需要做I18n的，但不用每篇文章都AI硬翻译成不同的意义，最佳实践：是针对不同的国家的关键词去完成文章生成。

紧接着执行`pnpm db:migrate-local`把本地的表先生成了，接下来完成后端的Api编写。

## 完成Api的编写

在`actions`里面添加`ai-content.ts`文件，这里就包含所有与AI内容生成相关的服务器端函数，值得注意的开发小习惯是：`尽量拆细一点，按照功能拆分`。

首先是`generateArticle`，这个函数是我们AI文章生成的核心，大部分都是常规逻辑，但是有一些地方需要我们关注一下：

1. 关于Prompt的写法，有一套最常用的模版，以Markdown的结构和层级来表示要求和重点，在开头完成角色定位，在结尾完成输出约束。
2. 在大多数场景都可以不要求强制以JSON输出，这会影响AI的自由度和输出，并且会遇到难以 `JSON.Parse` 的情况，采用以正则提取的方式是更好的选择。
3. 注意看这段价值万金的提示词：`Please use "keywords" as the keyword to search the first 20 search results on Google, and record their article structure and titles. Then, based on these contents, output an article that conforms to Google SEO logic and user experience. `
   这一句并不会真正的去联网搜索，但是我们想象一下AI的数据本身就是从各大搜索引擎爬取的，这样写提示词的方式会引导查找向量在它的大数据中的近似坐标附近进行输出和查找答案。（有点绕，Prompt本身就是不停帮助模型在它的大宇宙中修正坐标的，简单的理解这么写一句输出会好很多）
4. `typeof analysisResult === 'object'`这个写法是帮助TS类型推导。
5. I18n在有些语言需要在提示词中特别声明。
6. 这个提示词有很大的优化空间，好点的模型可以把具体的SEO的最佳文章实践和要求都写进去，这种低参数模型只能泛提示词了（不遵守细规则）。

```typescript
'use server'

import { desc, eq } from 'drizzle-orm'

import { locales } from '@/i18n/routing'
import { createAI } from '@/lib/ai'
import { createDb } from '@/lib/db'
import { posts } from '@/lib/db/schema'

interface ArticleGenerationParams {
  keyword: string
  locale?: string
}

interface BatchArticleGenerationParams {
  keywords: string[]
  locale?: string
}

function getLanguageNameFromLocale(localeCode: string): string {
  const locale = locales.find((l) => l.code === localeCode)
  if (locale) {
    return locale.name
  }
  return 'English'
}

export async function generateArticle({ keyword, locale = 'en' }: ArticleGenerationParams) {
  const languageName = getLanguageNameFromLocale(locale)

  const systemPrompt = `
  You are an SEO content writer. Your job is write blog post optimized for keyword, title and outline. Please use "keywords" as the keyword to search the first 20 search results on Google, and record their article structure and titles. Then, based on these contents, output an article that conforms to Google SEO logic and user experience. 

  Format requirements:
  - Start with a single H1 title (# Title) that is EXACTLY 50 characters or less
  - The title must include the main keyword and be compelling for readers
  - Use markdown formatting with proper heading structure (# for H1, ## for H2, etc.)
  - Include well-formatted paragraphs, lists, and other elements as appropriate
  - Maintain a professional, informative tone
  
  SEO requirements:
  - Make the first paragraph suitable for a meta description
  - Answer common user questions related to the topic in a conversational tone
  - Write in a natural, flowing style that mimics human writing patterns with varied sentence structures
  - Avoid obvious AI patterns like excessive lists and formulaic paragraph structures
  - Incorporate personal anecdotes, analogies, and relatable examples where appropriate
  - Include the most up-to-date information and recent developments on the topic
  - Ensure comprehensive coverage with sufficient depth (minimum 1500 words)
  
  Language requirement:
  - Write the entire article in ${languageName} language
  - Ensure the content is culturally appropriate for ${languageName}-speaking audiences
  - Use proper grammar, idioms, and expressions specific to ${languageName}
  ${locale === 'ar' ? '- Follow right-to-left (RTL) text conventions' : ''}
  
  IMPORTANT: At the very end of your response, include two separate sections:
  1. "META_DESCRIPTION:" followed by a concise, SEO-friendly excerpt (130-140 characters max) that includes the main keyword naturally.
  2. "URL_SLUG:" followed by an SEO-friendly URL slug for this article (lowercase, words separated by hyphens, no special characters).
  
  Produce original, accurate, and valuable content of at least 10,000 tokens. Output the article content, starting with the H1 title, followed by the meta description and URL slug sections at the end.`

  const userPrompt = `Create an article about "${keyword}" in ${languageName} language. Optimize it for search engines while maintaining high-quality, valuable content for readers.`

  try {
    const cloudflareAI = createAI()

    const analysisResult = await cloudflareAI.run('@cf/meta/llama-4-scout-17b-16e-instruct', {
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      stream: false,
      max_tokens: 16000
    })

    if (typeof analysisResult === 'object') {
      const fullResponse = analysisResult.response

      const metaDescriptionMatch = fullResponse.match(/META_DESCRIPTION:\s*([\s\S]*?)(?=URL_SLUG:|$)/)
      const excerpt = metaDescriptionMatch ? metaDescriptionMatch[1].trim() : ''

      const urlSlugMatch = fullResponse.match(/URL_SLUG:\s*([\s\S]+)$/)
      let slug = urlSlugMatch ? urlSlugMatch[1].trim() : ''

      let content = fullResponse
      if (metaDescriptionMatch) {
        content = content.replace(/META_DESCRIPTION:[\s\S]*$/, '').trim()
      }

      const titleMatch = content.match(/^#\s+(.+)$/m)
      const extractedTitle = titleMatch ? titleMatch[1].trim() : 'Untitled Article'

      if (!slug) {
        slug = extractedTitle
          .toLowerCase()
          .trim()
          .replace(/\s+/g, '-')
          .replace(/[^\w\-]+/g, '')
          .replace(/\-\-+/g, '-')
      }

      return {
        title: extractedTitle,
        slug,
        content,
        excerpt: excerpt || content.substring(0, 140) + '...',
        locale
      }
    }
  } catch (error) {
    throw error
  }
}
```

常规CRUD，注意类型和一些默认值的情况，没啥好讲的。

```typescript
// 将生成的文章保存到数据库
export async function saveGeneratedArticle(
  article: {
    title: string
    slug: string
    content: string
    excerpt: string
    locale?: string
  },
  publishImmediately = true
) {
  const database = createDb()

  // 准备文章数据
  const postData = {
    slug: article.slug,
    title: article.title,
    excerpt: article.excerpt,
    content: article.content,
    locale: article.locale || 'en',
    publishedAt: publishImmediately ? new Date() : undefined,
    createdAt: new Date(),
    updatedAt: new Date()
  }

  await database.insert(posts).values(postData)
}

export async function getAllArticles(locale?: string) {
  const database = createDb()
  const query = database.select().from(posts).orderBy(desc(posts.publishedAt))

  if (locale) {
    return await query.where(eq(posts.locale, locale))
  }

  return await query
}

// 根据 slug 获取单篇文章
export async function getArticleBySlug(slug: string) {
  const database = createDb()
  const result = await database.select().from(posts).where(eq(posts.slug, slug))
  return result[0] || null
}

// 更新文章
export async function updateArticle(
  slug: string,
  data: {
    title?: string
    content?: string
    excerpt?: string
    publishedAt?: Date | null
    locale?: string
  }
) {
  const database = createDb()
  const updateData = {
    ...data,
    updatedAt: new Date()
  }

  await database.update(posts).set(updateData).where(eq(posts.slug, slug))

  // 返回更新后的文章
  return getArticleBySlug(slug)
}

// 删除文章
export async function deleteArticle(slug: string) {
  const database = createDb()
  await database.delete(posts).where(eq(posts.slug, slug))
  return { success: true }
}
```

肯定我们也需要添加批量生成和保存文章的功能，这里稍微就是要注意一下的是异常处理（把错误的返回，方便重新生成）和并发频次。

```typescript
export async function generateBatchArticles(params: BatchArticleGenerationParams) {
  const { keywords, locale = 'en' } = params
  const concurrencyLimit = 10
  const results = []

  for (let i = 0; i < keywords.length; i += concurrencyLimit) {
    const batch = keywords.slice(i, i + concurrencyLimit)
    const batchPromises = batch.map(async (keyword) => {
      try {
        const article = await generateArticle({ keyword, locale })
        return {
          keyword,
          article,
          status: 'success'
        }
      } catch (error) {
        return {
          keyword,
          error: error instanceof Error ? error.message : 'Unknown error',
          status: 'error'
        }
      }
    })

    const batchResults = await Promise.all(batchPromises)
    results.push(...batchResults)
  }

  return results
}

export async function saveBatchArticles(
  articles: Array<{
    title: string
    slug: string
    content: string
    excerpt: string
    locale?: string
    selected?: boolean
  }>,
  publishImmediately = true
) {
  const database = createDb()
  const results = []

  const articlesToSave = articles.filter((article) => article.selected !== false)

  const batchSize = 10
  for (let i = 0; i < articlesToSave.length; i += batchSize) {
    const batch = articlesToSave.slice(i, i + batchSize)

    const savePromises = batch.map(async (article) => {
      try {
        const postData = {
          slug: article.slug,
          title: article.title,
          excerpt: article.excerpt,
          content: article.content,
          locale: article.locale || 'en',
          publishedAt: publishImmediately ? new Date() : undefined,
          createdAt: new Date(),
          updatedAt: new Date()
        }

        await database.insert(posts).values(postData)
        return {
          title: article.title,
          status: 'success'
        }
      } catch (error) {
        return {
          title: article.title,
          status: 'error',
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      }
    })

    const batchResults = await Promise.all(savePromises)
    results.push(...batchResults)
  }

  return results
}
```

API函数功能总结：

1. `generateArticle`: 根据关键词和语言生成单篇文章
2. `saveGeneratedArticle`: 将生成的文章保存到数据库
3. `getAllArticles`: 获取所有文章，可按语言筛选
4. `getArticleBySlug`: 通过slug获取单篇文章
5. `updateArticle`: 更新现有文章
6. `deleteArticle`: 删除文章
7. `generateBatchArticles`: 批量生成多篇文章
8. `saveBatchArticles`: 批量保存多篇文章

## 前端部分

整个前端的部分，都是纯业务，细讲代码太浪费篇幅了，讲一讲我的思考逻辑和比较重要的点。

### Admin的权限判断

显然单独去写个生成后台是一件比较费劲的事情，所以就直接在项目里完成了，但是需要控制权限怎么办？我采用了最简单的方式。

首先我们需要在`lib/auth.ts`中为返回的 `user` 信息添加一个 `id`，这里 `token` 是解出来之后的信息我们加一个用户的 `id`，然后在`session`里增加一个 `id`的返回。

```typescript
  session: {
    strategy: 'jwt'
  },
  callbacks: {
    jwt: async ({ token, user }) => {
      if (user) {
        token.id = user.id
      }
      return token
    },
    session: async ({ session, token }) => {
      if (token && session.user) {
        session.user.id = token.id as string
      }
      return session
    }
  }
```

然后在 `app/[locale]/admin/layout.tsx` 这个大布局文件中，user中就会拥有一个 `id`，最终我们添加一个环境变量，这个环境变量就是自己登陆时候的`id`，不是你的`id`就直接重定向到首页。就把最简单的权限搞定了。

```typescript
import { ReactNode } from 'react'

import { redirect } from '@/i18n/navigation'
import { auth } from '@/lib/auth'

export const runtime = 'edge'

export default async function AdminLayout({
  children,
  params
}: {
  children: ReactNode
  params: Promise<{ locale: string }>
}) {
  const { locale } = await params
  const s = await auth()
  if (s?.user?.id !== process.env.NEXT_PUBLIC_ADMIN_ID) {
    redirect({
      href: '/',
      locale
    })
  }
  return <div className="py-8">{children}</div>
}
```

> 如果是需要给其他人操作后台的权限，把环境变量以,分割，在判断的地方改成`process.env.NEXT_PUBLIC_ADMIN_ID.split(',').includes(s?.user?.id)`。

### Admin的四个主要页面功能

#### 1. 文章列表页面 (Articles List)

文章列表页面是管理员模块的中心枢纽，提供了所有文章的概览和管理入口。

1. **文章展示**：以表格形式展示所有文章，包括标题、创建日期、语言、发布状态等信息
2. **空状态处理**：当没有文章时显示提示信息
3. **快速操作**：提供编辑和查看链接，方便管理员快速访问特定文章
4. **创建入口**：顶部提供两个按钮，分别用于创建新文章和批量创建文章
5. **状态标识**：使用不同颜色的标签区分已发布和草稿状态
6. **多语言支持**：显示每篇文章的语言，支持多语言内容管理
7. **直观导航**：从列表可以直接跳转到编辑页面或查看发布后的文章

#### 2. 新文章创建页面 (New Article)

新文章创建页面提供了AI辅助的内容生成功能，让管理员能够快速创建高质量文章。

1. **关键词输入**：通过关键词指导AI生成相关内容
2. **语言选择**：支持多语言文章创建，从预定义的语言列表中选择
3. **AI生成**：调用后端AI服务生成文章标题、摘要和内容
4. **内容编辑**：生成后可以手动编辑所有字段，包括标题、slug、摘要和正文
5. **发布控制**：可选择立即发布或保存为草稿
6. **表单验证**：防止空关键词提交等无效操作
7. **返回功能**：可以随时返回文章列表页面
8. **操作反馈**：所有操作都有明确的成功或失败提示

#### 3. 文章编辑页面 (Edit Article)

编辑页面允许管理员修改现有文章的所有方面，包括内容和发布状态，还提供了删除功能。

1. **文章加载**：根据slug参数加载特定文章的所有信息
2. **全面编辑**：修改标题、摘要和正文内容
3. **发布切换**：通过开关控制文章的发布状态，可以将草稿发布或将已发布文章转为草稿
4. **删除功能**：提供删除文章的选项，带确认对话框防止误操作
5. **保存更新**：将修改保存到数据库并返回列表页面
6. **错误处理**：完善的错误处理和用户反馈
7. **预览功能**：可以在新标签页中预览文章效果
8. **取消编辑**：可以不保存更改直接返回列表页面

#### 4. 批量创建页面 (Batch Create)

批量创建页面允许管理员一次性生成多篇相关文章，提高内容创建效率。

1. **主题输入**：输入一个主题或领域，作为批量生成的基础
2. **数量控制**：指定要生成的文章数量，可以根据需要调整
3. **语言选择**：选择生成文章的语言，支持多语言批量创建
4. **批量生成**：一键生成多篇相关文章，每篇文章围绕主题但有不同角度
5. **批量预览**：预览生成的所有文章标题和摘要，便于快速评估质量
6. **选择性保存**：可以选择保存全部或部分生成的文章，灵活控制
7. **发布设置**：统一设置所有文章的发布状态，可以全部发布或保存为草稿
8. **批量操作**：支持全选/取消全选等批量操作功能
9. **进度指示**：显示生成和保存过程的进度状态

#### Admin总结

这四个页面共同构成了一个完整的内容管理系统

1. **文章列表页面**：提供内容概览和管理入口，是整个系统的导航中心
2. **新文章创建页面**：支持AI辅助的单篇文章创建，适合精细化内容生产
3. **文章编辑页面**：提供全面的内容编辑和管理功能，确保内容质量
4. **批量创建页面**：实现高效率的内容批量生产，适合快速填充网站内容

### 展示的页面与Sitemap

一个集合展示页：app/[locale]/blogs， 一个单独的文章展示页：app/[locale]/blog。

#### 集合页

值得注意的是这一行代码`const allArticles = await getAllArticles(locale)`，这里的意思是只展示当前语言下的对应文章。

```typescript
const { locale } = await params
const allArticles = await getAllArticles(locale)
const t = await getTranslations('blogs')

const publishedArticles = allArticles.filter((article) => article.publishedAt)
```

另外在`generateMetadata`中需要在后面跟一下品牌名，这是一个SEO的常见做法。

```typescript
export async function generateMetadata(): Promise<Metadata> {
  const t = await getTranslations('blogs')
  const siteInfoT = await getTranslations('siteInfo')

  return {
    title: t('metaTitle', { brandName: siteInfoT('brandName') }),
    description: t('metaDescription')
  }
}
```

#### Blog展示页

没有特别的地方，主要是`BlogBody`渲染请求回来的`Markdown`，有一些组件我进行了优化和替换。

```typescript
import Markdown from 'markdown-to-jsx'

import CodeBlock from '@/components/markdown/code'
import Heading from '@/components/markdown/heading'
import ImageBlock from '@/components/markdown/img'
import PBlock from '@/components/markdown/p'
import VideoBlock from '@/components/markdown/video'

interface BlogBodyProps {
  content: string
}

const BlogBody = ({ content }: BlogBodyProps) => {
  return (
    <Markdown
      options={{
        overrides: {
          p: ({ children }) => <PBlock>{children}</PBlock>,
          h1: ({ children }) => <Heading level={1}>{children}</Heading>,
          h2: ({ children }) => <Heading level={2}>{children}</Heading>,
          h3: ({ children }) => <Heading level={3}>{children}</Heading>,
          h4: ({ children }) => <Heading level={4}>{children}</Heading>,
          h5: ({ children }) => <Heading level={5}>{children}</Heading>,
          h6: ({ children }) => <Heading level={6}>{children}</Heading>,
          pre: ({ children }) => <>{children}</>,
          code: ({ className, children }) => <CodeBlock className={className}>{children}</CodeBlock>,
          img: ({ src, alt }) => <ImageBlock src={src} alt={alt} />,
          CustomVideo: ({ src, title }) => <VideoBlock src={src} title={title} />
        }
      }}
    >
      {content}
    </Markdown>
  )
}

export default BlogBody
```

#### Sitemap

`unstable_noStore`的含义是每次都动态生成。

```ts
import { unstable_noStore } from 'next/cache'

import { getAllArticles } from '@/actions/ai-content'
import { locales } from '@/i18n/routing'

import type { MetadataRoute } from 'next'

export const runtime = 'edge'

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  unstable_noStore()

  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL

  const routes = ['', '/about', '/blogs']

  // 为每个路由和每种语言创建sitemap条目
  const entries: MetadataRoute.Sitemap = []

  for (const route of routes) {
    for (const locale of locales) {
      entries.push({
        url: `${baseUrl}/${locale.code}${route}`
      })
    }
  }

  const allArticles = await getAllArticles()

  const publishedArticles = allArticles
    .filter((article) => article.publishedAt)
    .map((i) => ({
      url: `${baseUrl}/${!i.locale || i.locale === 'en' ? '' : i.locale + '/'}blog/${i.slug}`
    }))

  return [...entries, ...publishedArticles]
}
```

## 结束

这一节通过AI生成就完结了，大家可以先等一等，下一章中会优化整体项目，比如：接口分页、Header、Footer等的每一个部分。
