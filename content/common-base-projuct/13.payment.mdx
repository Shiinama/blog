# 支付基建

支付基建分为三章，第一章章是有关核心业务的支付基建，第二章是关于三方的支付接入，第三章是后台+用户支付融合。

这也是分成两层，当底层的表结构和核心API完成后，上层就仅仅只是扩展第三方的支付方式与兼容当前的支付设计与业务部分。

[本章Tag](https://github.com/Shiinama/next-cloudflare-template/tree/v10.0.0)

## 支付相关的表结构

支付相关有核心的四张表：产品表、订单表、订阅表、交易历史表。

### 1. 产品表 (products)

产品表存储所有可购买的产品或订阅的信息。

```typescript
export type ProductType = 'one_time' | 'subscription'
export type Currency = 'USD' | 'CNY' | 'EUR' | 'JPY' | 'GBP'
export type SubscriptionInterval = 'day' | 'week' | 'month' | 'year'

export const products = sqliteTable('products', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text('name').notNull(),
  description: text('description'),
  type: text('type').$type<ProductType>().notNull(),
  price: real('price').notNull(),
  currency: text('currency').$type<Currency>().notNull().default('USD'),
  interval: text('interval').$type<SubscriptionInterval>(), // 仅用于订阅
  tokenAmount: integer('tokenAmount'), // 如果产品提供tokens
  active: integer('active', { mode: 'boolean' }).notNull().default(true),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull()
})
```

**字段解释：**

1. **name**: 产品名称，必填字段
2. **description**: 产品描述
3. **type**: 产品类型，使用`ProductType`枚举类型，可以是一次性购买(`one_time`)或订阅(`subscription`)
4. **price**: 产品价格，使用浮点数存储
5. **currency**: 货币类型，使用`Currency`枚举类型，默认为USD
6. **interval**: 订阅周期，仅对订阅类型产品有效，可以是天(`day`)、周(`week`)、月(`month`)或年(`year`)
7. **tokenAmount**: 产品提供的token数量，对于提供token的产品使用
8. **active**: 产品是否激活，布尔值，默认为true
9. **createdAt**: 产品创建时间，自动设置为当前时间戳
10. **updatedAt**: 产品更新时间，自动设置为当前时间戳

### 2. 订单表 (orders)

订单表记录所有交易信息，包括一次性购买和订阅的初始交易。

```typescript
export type OrderStatus = 'pending' | 'completed' | 'failed' | 'refunded'

export type PaymentMethod = 'credit_card' | 'paypal' | 'upgrade.chat' | 'other'

export const orders = sqliteTable('orders', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text('userId')
    .notNull()
    .references(() => users.id),
  productId: text('productId')
    .notNull()
    .references(() => products.id),
  amount: real('amount').notNull(),
  currency: text('currency').$type<Currency>().notNull(),
  status: text('status').$type<OrderStatus>().notNull().default('pending'),
  paymentMethod: text('paymentMethod').$type<PaymentMethod>(),
  paymentIntentId: text('paymentIntentId'), // 支付网关的交易ID
  metadata: text('metadata'), // 存储JSON格式的额外信息
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull()
})
```

**字段解释：**

1. **userId**: 下单用户的ID，外键关联到users
2. **productId**: 购买的产品ID，外键关联到products表
3. **amount**: 订单金额，使用浮点数存储
4. **currency**: 货币类型，使用`Currency`枚举类型
5. **status**: 这是用来跟踪订单的完整生命周期，订单状态，使用`OrderStatus`枚举类型，默认为`pending`，可以是待处理(`pending`)、已完成(`completed`)、失败(`failed`)或已退款(`refunded`)
6. **paymentMethod**: 支付方式，使用`PaymentMethod`枚举类型，可以是信用卡(`credit_card`)、PayPal(`paypal`)等
7. **paymentIntentId**: 外部支付网关的交易ID，用于与支付服务提供商集成
8. **metadata**: 额外的元数据，以JSON格式存储，可用于存储特定于业务的信息
9. **createdAt**: 订单创建时间，自动设置为当前时间戳
10. **updatedAt**: 订单更新时间，自动设置为当前时间戳

### 3. 订阅表 (subscriptions)

订阅表记录用户的活跃订阅信息，跟踪订阅的状态和周期。

```typescript
export type SubscriptionStatus = 'active' | 'canceled' | 'expired' | 'past_due'

export const subscriptions = sqliteTable('subscriptions', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  productId: text('productId')
    .notNull()
    .references(() => products.id),
  orderId: text('orderId').references(() => orders.id),
  status: text('status').$type<SubscriptionStatus>().notNull().default('active'),
  currentPeriodStart: integer('current_period_start', { mode: 'timestamp_ms' }).notNull(),
  currentPeriodEnd: integer('current_period_end', { mode: 'timestamp_ms' }).notNull(),
  cancelAtPeriodEnd: integer('cancel_at_period_end', { mode: 'boolean' }).default(false),
  subscriptionId: text('subscriptionId'), // 支付网关的订阅ID
  metadata: text('metadata'), // 存储JSON格式的额外信息
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull()
})
```

**字段解释：**

1. **userId**: 订阅用户的ID，外键关联到users表
2. **productId**: 订阅的产品ID，外键关联到products表
3. **orderId**: 创建此订阅的初始订单ID，外键关联到orders表
4. **status**: 订阅状态，使用`SubscriptionStatus`枚举类型，默认为`active`，可以是活跃(`active`)、已取消(`canceled`)、已过期(`expired`)或逾期未付(`past_due`)
5. **currentPeriodStart**: 当前订阅周期的开始时间，时间戳格式
6. **currentPeriodEnd**: 当前订阅周期的结束时间，时间戳格式
7. **cancelAtPeriodEnd**: 是否在当前周期结束时取消订阅，布尔值，默认为false
8. **subscriptionId**: 外部支付网关的订阅ID，用于与支付服务提供商集成
9. **metadata**: 额外的元数据，以JSON格式存储
10. **createdAt**: 订阅创建时间，自动设置为当前时间戳
11. **updatedAt**: 订阅更新时间，自动设置为当前时间戳

### 4. 交易历史表 (transactions)

交易历史表记录所有token余额的变动，包括购买、使用、退款等操作。

```typescript
export const transactions = sqliteTable('transactions', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  orderId: text('orderId').references(() => orders.id),
  type: text('type').$type<TransactionType>().notNull(),
  amount: integer('amount').notNull(), // token数量，可以是正数(增加)或负数(消费)
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .default(sql`CURRENT_TIMESTAMP`)
    .notNull()
})
```

**字段解释：**

1. **userId**: 交易关联的用户ID，外键关联到users表，设置了级联删除
2. **orderId**: 关联的订单ID（如果适用），外键关联到orders表
3. **type**: 交易类型，使用`TransactionType`枚举类型，可以是购买(`purchase`)、使用(`usage`)、退款(`refund`)、订阅续费(`subscription_renewal`)、赠送(`gift`)或促销(`promotion`)
4. **amount**: token数量变化，整数类型，正数表示增加，负数表示消费
5. **createdAt**: 交易创建时间，自动设置为当前时间戳

### 表之间的关系与数据流

我们来梳理一下所有表之间的数据流向和业务逻辑

#### 1. **用户购买产品**:

- 创建`orders`表记录，状态为`pending`
- 支付成功后，更新`orders`表记录状态为`completed`
- 创建`transactions`表记录，类型为`purchase`，金额为正数
- 更新`userUsage`表，增加`totalTokens`

**数据流向**：

```
products → orders → transactions → userUsage
```

**业务逻辑**：
用户选择一次性购买产品后，系统首先创建订单记录，然后处理支付。支付成功后，系统更新订单状态，并创建一条交易记录来记录代币的增加，同时更新用户的代币总量。这样用户就可以使用这些代币来访问系统的功能。

#### 2. **用户订阅产品**:

- 创建`orders`表记录，状态为`pending`
- 支付成功后，更新`orders`表记录状态为`completed`
- 创建`subscriptions`表记录，设置周期起止时间
- 创建`transactions`表记录，类型为`purchase`，金额为正数
- 更新`userUsage`表，增加`totalTokens`

**数据流向**：

```
products → orders → subscriptions → transactions → userUsage
```

> 订单表记录的是财务关系，订阅表记录的是持续服务关系，一个订阅可能关联多个订单，这也是需要拉2个表的原因。在系统设计上要明确的区别`支付关系`和`服务关系`。

**业务逻辑**：
用户选择订阅产品后，系统首先创建订单记录，然后处理首次支付。支付成功后，系统更新订单状态，创建订阅记录（包含当前周期的开始和结束时间），并创建一条交易记录来记录代币的增加，同时更新用户的代币总量。订阅记录会跟踪服务的有效期，而订单记录则跟踪财务交易。

#### 3. **订阅续费**:

这里很烦的是有两种情况，一种情况你的订阅是完全依赖上游支付厂商的通知来订阅的，另外一种情况是要需要你手动请求后续周期的订阅。

- 检查`subscriptions`表中即将到期的记录
- 处理续费支付（手动发起/或者被通知），创建新的`orders`表记录
- 更新`subscriptions`表中的周期信息
- 创建新的`transactions`表记录，类型为`subscription_renewal`，金额为正数
- 更新`userUsage`表，增加`totalTokens`

**数据流向**：

```
subscriptions → orders → transactions → userUsage
```

**业务逻辑**：
当订阅周期即将结束时，系统会自动处理续费。续费成功后，系统会创建新的订单记录（记录这次财务交易），更新订阅的周期信息（延长服务期限），创建一条交易记录来记录代币的增加，并更新用户的代币总量。这样用户可以继续享受订阅服务并获得新的代币。

#### 4. **用户使用token**:

- 检查`userUsage`表确认用户有足够的可用代币
- 创建`transactions`表记录，类型为`usage`，金额为负数
- 更新`userUsage`表，增加`usedTokens`

**数据流向**：

```
userUsage → transactions → userUsage
```

**业务逻辑**：
当用户使用系统功能需要消耗代币时，系统首先检查用户是否有足够的可用代币（totalTokens - usedTokens）。如果足够，系统会创建一条交易记录，记录代币的消耗（负数金额），并更新用户已使用的代币数量。这样系统可以准确跟踪用户的代币使用情况，同时保留完整的使用历史。

#### 5. **订阅取消**:

- 更新`subscriptions`表中的状态或`cancelAtPeriodEnd`字段
- 如果是立即取消并有退款，创建新的`orders`表记录，状态为`refunded`
- 如果有退款，创建`transactions`表记录，类型为`refund`，金额为负数
- 更新`userUsage`表，减少`totalTokens`

**数据流向**：

```
subscriptions → orders → transactions → userUsage
```

**业务逻辑**：
用户取消订阅时，系统会更新订阅状态。如果是在周期结束时取消，系统只需标记不再自动续费。如果是立即取消并需要退款，系统会创建退款订单记录，创建一条退款交易记录（负数金额），并相应减少用户的代币总量。

### 一个Token与支付的例子

假设我们有一个AI内容生成平台：

1. **订阅计划**:

   - 基础版：$9.99/月，每月提供500个token
   - 专业版：$19.99/月，每月提供1200个token
   - 企业版：$49.99/月，每月提供3000个token

2. **一次性购买选项**:

   - 小包：$4.99，获得200个token
   - 中包：$9.99，获得450个token
   - 大包：$19.99，获得1000个token

3. **使用场景**:
   - 用户小明订阅了基础版，每月自动获得500个token
   - 某个月他需要生成更多内容，于是额外购买了一个中包，获得450个token
   - 现在他有950个token可以使用
   - 下个月初，他的订阅自动续费，系统再次给他添加500个token
   - 如果他这个月没用完之前的token，那么新的余额将是：(950 - 已使用量) + 500

市面上有两种模式，一个是完全结转模式（允许未使用的token完全结转，没有过期时间），另外一个是不结转模式（清零前面没用完的Token，这其实不是主流）。

我们从两个角度去思考这件事：

1. **产品视角**：

   - 完全结转模式：用户感知价值高，认为"买到就是自己的"，用户可以根据自己的使用节奏灵活安排token消费，提高用户满意度和忠诚度，并且可以以这个差异点吸引用户。
   - 不结转模式：每个订阅周期产生固定收入，不会因用户积累token而延迟消费，收入和资源的预测会更简单。

2. **技术实现视角**：
   - 完全结转模式：只需要在`transactions`表中记录所有token的增减，用户余额就是所有交易的总和。实现简单，数据模型清晰。
   - 不结转模式：需要在token记录中添加过期时间，并定期清理过期token，增加了实现复杂度。

完全结转策略虽然在财务预测和资源规划方面虽然会做得特别难，但在用户体验、品牌差异化和长期客户关系建设方面具有显著优势。它特别适合新进入市场的服务、使用成本相对稳定的产品。

另外一个方面就是复杂度，`在没赚钱之前所有的技术复杂度都只是浪费时间和空想`，不结转的复杂度是成指数上升的。这也是我最终选择`完全结转`的核心原因。

## 完成基础的API

在理清楚业务逻辑和怎么做之后，我们还需要完成基础API的编写

### 产品信息

产品的信息的API：`actions/payment/products.ts`，这部分很简单只需要获取产品列表以及产品详情。

```typescript
'use server'

import { eq } from 'drizzle-orm'

import { createDb } from '@/lib/db'
import { products } from '@/lib/db/schema'

const db = createDb()

// 获取所有激活的产品
export async function getActiveProducts() {
  return await db.query.products.findMany({
    where: eq(products.active, true),
    orderBy: (products, { asc }) => [asc(products.price)]
  })
}

// 获取单个产品详情
export async function getProductById(productId: string) {
  const product = await db.query.products.findFirst({
    where: eq(products.id, productId)
  })

  if (!product) {
    throw new Error('Product not found')
  }

  return product
}
```

### 订单逻辑处理

订单信息的API：`actions/payment/orders.ts`。订单的关注重点是在于订单的创建、流转、查询。

```typescript
'use server'

import { eq } from 'drizzle-orm'

import { auth } from '@/lib/auth'
import { createDb } from '@/lib/db'
import {
  orders,
  subscriptions,
  transactions,
  userUsage,
  OrderStatus,
  PaymentMethod,
  SubscriptionStatus,
  TransactionType
} from '@/lib/db/schema'

import { getProductById } from './products'

const db = createDb()

// 创建新订单
export async function createOrder({ productId, paymentMethod }: { productId: string; paymentMethod: PaymentMethod }) {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  const userId = session.user.id

  // 获取产品信息
  const product = await getProductById(productId)

  if (!product.active) {
    throw new Error('Product is not available')
  }

  // 创建订单
  const [order] = await db
    .insert(orders)
    .values({
      userId,
      productId,
      amount: product.price,
      currency: product.currency,
      status: 'pending' as OrderStatus,
      paymentMethod
    })
    .returning()

  return order
}

// 处理订单支付成功
export async function handlePaymentSuccess({
  orderId,
  paymentIntentId,
  metadata
}: {
  orderId: string
  paymentIntentId?: string
  metadata?: string
}) {
  // 获取订单信息
  const order = await db.query.orders.findFirst({
    where: eq(orders.id, orderId)
  })

  if (!order) {
    throw new Error('Order not found')
  }

  if (order.status === 'completed') {
    return order // 订单已经处理过
  }

  // 获取产品信息
  const product = await getProductById(order.productId)

  // 更新订单状态
  await db
    .update(orders)
    .set({
      status: 'completed' as OrderStatus,
      paymentIntentId,
      metadata,
      updatedAt: new Date()
    })
    .where(eq(orders.id, orderId))

  // 如果是订阅产品，创建订阅记录
  if (product.type === 'subscription') {
    const now = new Date()
    const currentPeriodEnd = new Date()

    // 根据订阅周期设置结束时间
    switch (product.interval) {
      case 'day':
        currentPeriodEnd.setDate(now.getDate() + 1)
        break
      case 'week':
        currentPeriodEnd.setDate(now.getDate() + 7)
        break
      case 'month':
        currentPeriodEnd.setMonth(now.getMonth() + 1)
        break
      case 'year':
        currentPeriodEnd.setFullYear(now.getFullYear() + 1)
        break
      default:
        throw new Error('Invalid subscription interval')
    }

    // 创建订阅记录
    await db.insert(subscriptions).values({
      userId: order.userId,
      productId: product.id,
      orderId: order.id,
      status: 'active' as SubscriptionStatus,
      currentPeriodStart: now,
      currentPeriodEnd,
      cancelAtPeriodEnd: false,
      subscriptionId: paymentIntentId
    })
  }

  // 如果产品提供token，添加交易记录并更新用户token余额
  if (product.tokenAmount) {
    // 创建交易记录
    await db.insert(transactions).values({
      userId: order.userId,
      orderId: order.id,
      type: 'purchase' as TransactionType,
      amount: product.tokenAmount
    })

    // 获取用户当前使用情况
    const usage = await db.query.userUsage.findFirst({
      where: eq(userUsage.userId, order.userId)
    })

    if (usage) {
      // 更新现有记录
      await db
        .update(userUsage)
        .set({
          totalTokens: usage.totalTokens + product.tokenAmount
        })
        .where(eq(userUsage.userId, order.userId))
    } else {
      // 创建新记录
      await db.insert(userUsage).values({
        userId: order.userId,
        usedTokens: 0,
        totalTokens: product.tokenAmount
      })
    }
  }

  return await db.query.orders.findFirst({
    where: eq(orders.id, orderId)
  })
}

// 获取用户订单历史
export async function getUserOrderHistory() {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  return await db.query.orders.findMany({
    where: eq(orders.userId, session.user.id),
    orderBy: (orders, { desc }) => [desc(orders.createdAt)],
    with: {
      product: true
    }
  })
}
```

### 订阅管理

订阅管理的API：`actions/payment/subscriptions.ts`。订阅的关注点是在于续费、取消、获得用户订阅状态。

```typescript
'use server'

import { eq, and } from 'drizzle-orm'

import { auth } from '@/lib/auth'
import { createDb } from '@/lib/db'
import { orders, subscriptions, OrderStatus, SubscriptionStatus } from '@/lib/db/schema'

import { getProductById } from './products'

import { updateUserTokens } from '@/actions/payment/tokens'

const db = createDb()

// 处理订阅续费
export async function handleSubscriptionRenewal({
  subscriptionId,
  paymentIntentId
}: {
  subscriptionId: string
  paymentIntentId?: string
}) {
  // 获取订阅信息
  const subscription = await db.query.subscriptions.findFirst({
    where: eq(subscriptions.id, subscriptionId)
  })

  if (!subscription) {
    throw new Error('Subscription not found')
  }

  if (subscription.status !== 'active') {
    throw new Error('Subscription is not active')
  }

  // 获取产品信息
  const product = await getProductById(subscription.productId)

  // 创建新的订单记录
  const [order] = await db
    .insert(orders)
    .values({
      userId: subscription.userId,
      productId: subscription.productId,
      amount: product.price,
      currency: product.currency,
      status: 'completed' as OrderStatus,
      paymentMethod: 'credit_card', // 假设使用信用卡续费
      paymentIntentId
    })
    .returning()

  // 更新订阅周期
  const newPeriodStart = new Date(subscription.currentPeriodEnd)
  const newPeriodEnd = new Date(subscription.currentPeriodEnd)

  switch (product.interval) {
    case 'day':
      newPeriodEnd.setDate(newPeriodStart.getDate() + 1)
      break
    case 'week':
      newPeriodEnd.setDate(newPeriodStart.getDate() + 7)
      break
    case 'month':
      newPeriodEnd.setMonth(newPeriodStart.getMonth() + 1)
      break
    case 'year':
      newPeriodEnd.setFullYear(newPeriodStart.getFullYear() + 1)
      break
  }

  await db
    .update(subscriptions)
    .set({
      currentPeriodStart: newPeriodStart,
      currentPeriodEnd: newPeriodEnd,
      updatedAt: new Date()
    })
    .where(eq(subscriptions.id, subscriptionId))

  // 如果产品提供token，添加交易记录并更新用户token余额
  if (product.tokenAmount) {
    await updateUserTokens({
      userId: subscription.userId,
      orderId: order.id,
      amount: product.tokenAmount,
      type: 'subscription_renewal'
    })
  }

  return order
}

// 取消订阅
export async function cancelSubscription({
  subscriptionId,
  cancelImmediately = false
}: {
  subscriptionId: string
  cancelImmediately?: boolean
}) {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  // 获取订阅信息
  const subscription = await db.query.subscriptions.findFirst({
    where: and(eq(subscriptions.id, subscriptionId), eq(subscriptions.userId, session.user.id))
  })

  if (!subscription) {
    throw new Error('Subscription not found or access denied')
  }

  if (cancelImmediately) {
    // 立即取消订阅
    await db
      .update(subscriptions)
      .set({
        status: 'canceled' as SubscriptionStatus,
        updatedAt: new Date()
      })
      .where(eq(subscriptions.id, subscriptionId))
  } else {
    // 在当前周期结束时取消
    await db
      .update(subscriptions)
      .set({
        cancelAtPeriodEnd: true,
        updatedAt: new Date()
      })
      .where(eq(subscriptions.id, subscriptionId))
  }

  return await db.query.subscriptions.findFirst({
    where: eq(subscriptions.id, subscriptionId)
  })
}

// 获取用户的活跃订阅
export async function getUserActiveSubscriptions() {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  const userId = session.user.id

  return await db.query.subscriptions.findMany({
    where: and(eq(subscriptions.userId, userId), eq(subscriptions.status, 'active')),
    with: {
      product: true
    }
  })
}
```

### 交易历史和Token管理

交易历史和Token管理的API：`actions/payment/tokens.ts`。这是交易历史和Token管理交融的部分（其实有一点耦合，但无伤大雅，这两块业务本身也是很耦合的）。

```typescript
'use server'

import { eq } from 'drizzle-orm'

import { auth } from '@/lib/auth'
import { createDb } from '@/lib/db'
import { transactions, userUsage, TransactionType } from '@/lib/db/schema'

const db = createDb()

// 更新用户token余额（内部函数）
export async function updateUserTokens({
  userId,
  orderId,
  amount,
  type
}: {
  userId: string
  orderId?: string
  amount: number
  type: TransactionType
}) {
  // 创建交易记录
  await db.insert(transactions).values({
    userId,
    orderId,
    type,
    amount
  })

  // 获取用户当前使用情况
  const usage = await db.query.userUsage.findFirst({
    where: eq(userUsage.userId, userId)
  })

  if (usage) {
    // 更新现有记录
    await db
      .update(userUsage)
      .set({
        totalTokens: usage.totalTokens + amount
      })
      .where(eq(userUsage.userId, userId))
  }
}

// 使用token
export async function updateUserTokenUsage({ amount }: { amount: number }) {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  const userId = session.user.id

  // 获取用户当前使用情况
  const usage = await db.query.userUsage.findFirst({
    where: eq(userUsage.userId, userId)
  })

  if (!usage) {
    throw new Error('No token balance found for user')
  }

  const availableTokens = usage.totalTokens - usage.usedTokens

  if (availableTokens < amount) {
    throw new Error('Insufficient token balance')
  }

  // 创建交易记录（使用负数表示消费）
  await db.insert(transactions).values({
    userId,
    type: 'usage' as TransactionType,
    amount: -amount // 负数表示消费
  })

  // 更新用户已使用的token数量
  await db
    .update(userUsage)
    .set({
      usedTokens: usage.usedTokens + amount
    })
    .where(eq(userUsage.userId, userId))

  return {
    success: true,
    remainingTokens: availableTokens - amount
  }
}

export async function hasEnoughTokens(requiredTokens: number) {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  const userId = session.user.id

  const usage = await db.query.userUsage.findFirst({
    where: eq(userUsage.userId, userId)
  })

  if (!usage) {
    return false
  }

  const remainingTokens = usage.totalTokens - usage.usedTokens

  return remainingTokens >= requiredTokens
}

// 获取用户token余额
export async function getUserTokenBalance() {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  const userId = session.user.id

  const usage = await db.query.userUsage.findFirst({
    where: eq(userUsage.userId, userId)
  })

  if (!usage) {
    return {
      totalTokens: 0,
      usedTokens: 0,
      availableTokens: 0
    }
  }

  return {
    totalTokens: usage.totalTokens,
    usedTokens: usage.usedTokens,
    availableTokens: usage.totalTokens - usage.usedTokens
  }
}

// 获取用户的交易历史
export async function getUserTransactionHistory() {
  const session = await auth()
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  const userId = session.user.id

  return await db.query.transactions.findMany({
    where: eq(transactions.userId, userId),
    orderBy: (transactions, { desc }) => [desc(transactions.createdAt)]
  })
}
```

## 结束

在本章中，我们主要探讨支付基建的核心组成部分，从数据库表结构设计到API实现。

在下一章中，我们将围绕如何将这套基础设施与第三方支付服务提供商集成，进一步完善我们的支付系统。通过这种分层设计，我们可以在保持核心业务逻辑稳定的同时，灵活应对不同支付渠道的特殊需求。
