---
title: 4.前端vue实战小测试
description: 前端vue实战小测试
published: true
toc:
  visible: true
date: 2022-12-09
---
 

# 前端vue实战小测试


## 问题1

我们先直觉判断一下，当`input value`大于5的时候是否会禁用。 
![image.png](https://ik.imagekit.io/leiakito/Vue3+ELLnput/3aea90470f644cd1b0dccbbf9a8b95e0~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp?updatedAt=1739723206913)
其实这题考的就是对象的引用，我们可以在浏览器上试试下面的内容会打印什么。

```js
let a = 1;
let b = {
  c: a
}
a = 3

```

讲解一下把再`inputValue`大于5的时候，我们看似改变了`disabled`，但实际上`buttonOption`里的`disabled`并没有改变，对于有时候会传一些复杂配置项的时候可能会遇到这个问题，这时候我们有个比较好的办法就是`computed`，`computed`会依赖收集，当依赖变化的时候，`buttonOption.disabled`的值就会相应变化。[在线地址](https://link.juejin.cn?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fwizardly-dubinsky-hilqyh%3Ffile%3D%2Fsrc%2FApp.vue "https://codesandbox.io/s/wizardly-dubinsky-hilqyh?file=/src/App.vue")。

![image.png](https://ik.imagekit.io/leiakito/Vue3+ELLnput/Vue%20%E5%AE%9E%E6%88%98%E5%B0%8F%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%981.webp?updatedAt=1739723206794)
## 问题2

老规矩直觉判断，当按钮点击的时候，是否会进行深监听，以及新旧value的值。 ![image.png](https://ik.imagekit.io/leiakito/Vue3+ELLnput/Vue%20%E5%AE%9E%E6%88%98%E5%B0%8F%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%981%20(1).webp?updatedAt=1739723207103)
此时我们监听了一个`reactive`定义的响应式数据，并且关闭了深监听，可是在打印中，我们依然进行了一个深监听，并且`oldValue`的值还是错误的。

然后我去翻了一下源码，一看不知道，原来不止是`reactive`定义的会有这个问题

我们先打一下断点

发现了一个问题，就是`oldValue`和`newValue`的引用是相同的，当`newValue`改变的时候`oldValue`也会改变。 ![image.png](https://ik.imagekit.io/leiakito/Vue3+ELLnput/Vue%20%E5%AE%9E%E6%88%98%E5%B0%8F%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%981%20(2).webp?updatedAt=1739723207302)这里我们看到最后，是导致`oldValue`和`newValue`引用相同的原因，而只有当我们直接性的使用一些引用类型进行监听的时候才会造成这个问题，而一些基本类型或者引用类型上的属性则不会造成`OldValue`的失效问题。

```js
function doWatch(
  source: WatchSource | WatchSource[] | WatchEffect | object,
  cb: WatchCallback | null,
  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ
): WatchStopHandle {
  //忽略代码
  const instance = currentInstance // 当前组件实例
  let getter: () => any //副作用参数
  let forceTrigger = false //是否强制更新
  let isMultiSource = false //数组开启
}
   // 组装setter
  if (isRef(source)) {
    getter = () => source.value
    // shallowRef也会有oldValue问题，性能优化用的这是
    forceTrigger = isShallow(source)
  } else if (isReactive(source)) {
    getter = () => source
    // 如果是reactive定义的会强制设置成deep，会有oldValue问题
    deep = true
  } 
  //忽略代码
    // 初始化 oldValue此时为{}
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE
  // 声明一个 job 调度器任务
  const job: SchedulerJob = () => {
    if (!effect.active) { // 如果副作用以停用则直接返回
      return
    }
    if (cb) {
      const newValue = effect.run()
      
      // 判断是否需要执行 cb
      // 1. getter 函数的值被改变，没有发生改变则不执行 cb 回调
      // 2. 设置了 deep 深度监听
      // 3. forceTrigger 为 true
      if (
        deep ||
        forceTrigger ||
        (isMultiSource
          ? (newValue as any[]).some((v, i) =>
              hasChanged(v, (oldValue as any[])[i])
            )
          : hasChanged(newValue, oldValue)) ||
        (__COMPAT__ &&
          isArray(newValue) &&
          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))
      ) {
        // cleanup before running cb again
        // 当回调再次执行前先清除副作用
        if (cleanup) {
          cleanup()
        }
        // 触发 watch api 的回调，并将 newValue、oldValue、onInvalidate 传入
        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          // 首次调用时，将 oldValue 的值设置为 undefined
          oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
          onInvalidate
        ])
        oldValue = newValue // 引用相同的罪魁祸首，当每次回调执行完走到着，会让oldValue和newValue保持相同的引用。
      }
    } else {
      effect.run()
    }
  }


```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032465d961f640ea92e8c8b8e30c21a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

# 总结

这几天一直在修前面`react`的源码解析，主要是我注意到了在`react`源码理解的最大难点是在于复杂的数据结构，和各种指针链表的引用，但刚才看了一下`v3`的`effect`和调度，感觉比`react`确实要好理解一些。