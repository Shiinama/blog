# 3. 核心功能实现：推送通知

**推送** 是移动应用的“再唤醒引擎”，也是闭环增长中唯一能够主动触达用户的渠道。一次成功的推送意味着你在用户刚刚停下刷剧时提醒他领取优惠券，在骑车到家前提前告知外卖即将送达，或是在他决定离开产品前拉他回到关键流程。真正的难点不在于技术栈会不会，而在于 “**用户画像 × 合适时机 × 有价值的内容 × 正确的落地体验**”。

本章节以 **Expo** 技术栈为主线，从 0 到 1 构建一个简单但完整的推送体系。

## 一、推送架构：APNs、FCM 与 Expo Push Service

移动推送涉及多个角色：设备与操作系统负责接收，**Apple** 与 **Google** 提供的原生推送网关负责传输，**Expo Push Service** 站在中台位置替我们做协议适配，而业务服务端承担“发什么、发给谁”的决策。理解链路中的分工，是我们后续定位问题、规划架构的前提。

我先描述一下原生写法的流程：在 **iOS** 里，`APNs` 是唯一合法的系统推送入口。应用首次启动会向系统注册，系统返回一个 `device token`，服务端需要携带 `APNs` 证书或 **p8 Token Auth** 向 **Apple** 的网关发送推送请求，Apple 再将消息投递到目标设备。整个过程强制使用 `TLS`，Apple 还提供了 `VoIP`、`Live Activities` 等附加能力。

**Android** 则以 **Firebase Cloud Messaging (FCM)** 为核心：客户端和 **Google Play services** 交互获得 `registration token`，服务端填入 `Server Key` 调用 `HTTP v1 API`。它支持把通知直接交给系统渲染，也支持只传输数据由应用自行决定表现形式。

**Expo Push Service** 相当于两者之上搭了一层“代发平台”。客户端通过 `expo-notifications` 获取的并不是 `APNs` 或 `FCM` 的 token，而是 **Expo Push Token**。你的服务端将推送请求发送给 Expo，Expo 再将消息路由到 `APNs` 或 `FCM`，并处理批量分片、速率限制和重试，还会统一返回错误码，避免我们直接面对各家规范。

链路大致长这样：

```text
客户端 (expo-notifications)
   |  注册并拿到 Expo Push Token
   v
业务服务端 (存储 Token / 触发推送)
   |  调用 Expo Push API
   v
Expo Push Service (校验 / 分片 / 重试)
   |  转发至 APNs / FCM
   v
目标设备 (系统策略决定呈现方式)
```

![](https://docs.expo.dev/static/images/sending-notification.png)

真实项目中，链路上最容易被忽视的点集中在三个方面。

1. **Token 生命周期**：同一个人可能同时使用两台手机，还会在不同账号间切换，如果不做好标签绑定和过期处理，就没法推送到正确的手机上。
2. **环境隔离**：开发、预发、生产的证书或 `Server Key` 一旦混用，测试同学一键触达全量真实用户的事故那就是。
3. **网络可达性**：跨境网络抖动会让 Expo/FCM 无法访问，提前准备连通性检测脚本能省掉半天排查时间。

## 二、平台凭证与权限配置

推送的可达性首先取决于 **凭证** 是否正确、**权限** 是否提前声明。我们可以先装好依赖并把配置集中在一处统一管理：

```bash
npx expo install expo-notifications expo-device expo-constants
```

```ts
// app.config.ts
export default {
  plugins: [
    [
      'expo-notifications',
      {
        icon: './assets/notification-icon.png',
        color: '#4f46e5',
        mode: process.env.APP_ENV === 'production' ? 'production' : 'development',
        sounds: ['./assets/sounds/order.wav']
      }
    ]
  ],
  ios: {
    supportsTablet: false,
    infoPlist: {
      NSUserNotificationUsageDescription: '我们将为你推送订单进度、优惠提醒等重要消息'
    }
  },
  android: {
    googleServicesFile: './android/app/google-services.json'
  },
  extra: {
    projectId: process.env.EAS_PROJECT_ID
  }
}
```

### iOS 凭证与权限配置

`APNs` 凭证决定了谁能代表你的 App 与 **Apple Push Notification service** 通信。常见形态有旧版的 `.p12` 证书和新版的 **APNs Auth Key**（`.p8`）。证书需要针对 `Development`、`Production` 分别生成，且每次续期都要重新导出；Auth Key 则是 `JWT` 方式，一把 Key 最多绑定 10 个 `Bundle Identifier`，可随时吊销，是 **Expo/EAS** 场景的首选。

完整落地可以拆成几个明确的动作：

1. 在 **Apple Developer Account** 创建 `App ID`，开启 **Push Notifications** 能力，并在 _Certificates, Identifiers & Profiles → Identifiers → App IDs_ 判断是否需要额外的通知扩展。随后到 _Certificates, Identifiers & Profiles → Keys_ 生成 **APNs Auth Key**，勾选绑定的 `Bundle ID`，注意 `.p8` 只会提供一次下载机会。
2. 通过 `eas credentials` 或 **EAS Dashboard** 上传 `.p8`，同时记录 `Key ID`、`Team ID` 和 **Apple Developer Account**，将它们写入 `eas.json` 中对应的 `build profile`。生产、灰度、测试建议使用独立的 `Bundle ID`（例如 `com.example.app`, `com.example.app.staging`），这样 `aps-environment` entitlement 才能保持隔离。
3. 在 `eas.json` 里显式声明凭证来源与权限：

```json
{
  "build": {
    "production": {
      "ios": {
        "resourceClass": "m-medium",
        "credentialsSource": "remote",
        "autoIncrement": true
      }
    }
  }
}
```

下面的流程图概览了整个凭证配置与 EAS 对接的链路：

```mermaid
flowchart TD
  A[创建 App ID 并开启 Push Notifications 能力] --> B[Keys 中生成 APNs Auth Key (.p8)]
  B --> C[下载 .p8<br/>记录 Key ID 与 Team ID]
  C --> D[使用 eas credentials / EAS Dashboard 上传凭证]
  D --> E[在 eas.json 中配置 bundleIdentifier<br/>credentialsSource=remote]
  E --> F[在 app.config.ts 补充权限描述与 UIBackgroundModes]
  F --> G[EAS Build 触发构建]
  G --> H[构建阶段自动拉取并注入远端凭证]
  H --> I[TestFlight 或 APNs Explorer 验证推送链路]
```

### Android 凭证与权限配置

可以看到在上文中声明了 `googleServicesFile`，请直接参造[文档](https://docs.expo.dev/push-notifications/fcm-credentials/)，创建 **Firebase** 项目并下载 `google-services.json`。**Expo Push Service** 会自动识别其中的 `Server Key` 并用于推送。

## 三、客户端权限、Token 获取与监听器

Expo 官方的 `expo-notifications` 在 **Managed** 与 **Bare** 两种工作流里都可用。下面这段代码展示了从注册到监听的完整流程：

```ts
// src/notifications.ts
import * as Device from 'expo-device'
import * as Notifications from 'expo-notifications'
import Constants from 'expo-constants'
import { Platform } from 'react-native'

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: true
  })
})

export async function registerForPushAsync() {
  if (!Device.isDevice) {
    throw new Error('需在真机上测试推送，模拟器不会返回有效 Token')
  }

  const { status: existingStatus } = await Notifications.getPermissionsAsync()
  let finalStatus = existingStatus

  if (existingStatus !== 'granted') {
    // iOS 端自定义权限选项，提前说明声音、角标用途
    const { status } = await Notifications.requestPermissionsAsync({
      ios: {
        allowAlert: true,
        allowSound: true,
        allowBadge: true,
        allowAnnouncements: false,
        provideAppNotificationSettings: true
      }
    })
    finalStatus = status
  }

  if (finalStatus !== 'granted') {
    throw new Error('用户未授予通知权限，可引导至系统设置手动开启')
  }

  if (Platform.OS === 'android') {
    await Notifications.setNotificationChannelAsync('default', {
      name: '默认通知',
      importance: Notifications.AndroidImportance.HIGH,
      vibrationPattern: [0, 250, 250, 250],
      lockscreenVisibility: Notifications.AndroidNotificationVisibility.PUBLIC,
      lightColor: '#4f46e5',
      sound: 'default'
    })
  }

  const projectId = Constants.expoConfig?.extra?.projectId
  if (!projectId) {
    throw new Error('缺少 projectId（请在 app.config.ts 的 extra.projectId 配置）')
  }

  const token = await Notifications.getExpoPushTokenAsync({ projectId })
  return token.data
}

export function listenNotifications() {
  const receiveListener = Notifications.addNotificationReceivedListener((notification) => {
    console.log('前台收到通知:', notification.request.content)
  })
  const responseListener = Notifications.addNotificationResponseReceivedListener((response) => {
    const data = response.notification.request.content.data as Record<string, unknown>
    console.log('用户点击通知，携带数据：', data)
  })
  return () => {
    receiveListener.remove()
    responseListener.remove()
  }
}
```

上文代码覆盖了注册与监听的核心环节，实战时请注意：

- **立即上报 Token**：拿到 **Expo Push Token** 后马上上传服务端，同时带上 `deviceId`、`locale`、`appVersion` 等维度，确保后续能做个性化和排查。
- **兜底错误提示**：网络波动、权限被拒绝都可能导致 `getExpoPushTokenAsync` 抛错，最好给用户一个明确提示。
- **冷启动监听**：在 App 冷启动阶段就注册 `addNotificationResponseReceivedListener`，保证用户点击通知时的上下文不会丢失。

实际接入时，我们会在应用生命周期的最外层挂上这段逻辑：

```ts
// App.tsx
useEffect(() => {
  let disposed = false
  registerForPushAsync()
    .then(async (token) => {
      if (disposed) return
      await api.user.updatePushToken({ token })
    })
    .catch((error) => {
      reportError(error)
    })
  const unsubscribe = listenNotifications()
  return () => {
    disposed = true
    unsubscribe()
  }
}, [])
```

## 四、服务端发送、储存与错误处理

客户端拿到 `Token` 只是开端，真正决定推送成败的还是服务端。一个成熟的推送服务通常会拆成三层：

- **入口 API**：接收业务请求，做参数校验与限流。
- **队列系统**：负责削峰填谷，保证高峰期不丢消息。
- **发送 worker**：与 **Expo** 打交道，处理批量分片、错误重试。

下面的示例聚焦在发送层，展示如何用 **Expo Server SDK** 做可靠投递：

```ts
// server/push/sendPush.ts
import { Expo, ExpoPushMessage, ExpoPushTicket } from 'expo-server-sdk'

const expo = new Expo({})

export async function sendPush(
  tokens: string[],
  payload: { title: string; body: string; data?: Record<string, unknown> }
) {
  const messages: ExpoPushMessage[] = tokens.map((to) => ({
    to,
    sound: 'default',
    title: payload.title,
    body: payload.body,
    data: payload.data,
    channelId: 'default',
    ttl: 3600,
    priority: 'high'
  }))

  const tickets: ExpoPushTicket[] = []
  for (const chunk of expo.chunkPushNotifications(messages)) {
    try {
      const ticketChunk = await expo.sendPushNotificationsAsync(chunk)
      tickets.push(...ticketChunk)
    } catch (error) {
      // 建议写入日志平台，结合 APM/告警
      console.error('发送推送失败', error)
    }
  }
  return tickets
}
```

Expo 返回的 `ticket` 只是“请求送到了 Expo”，真正的“是否投递成功”还得等 `receipt`。通常我们会把 `ticketId` 丢进队列，稍后批量查询：

```ts
export async function handleReceipt(ticketIds: string[]) {
  const receiptChunks = expo.chunkPushNotificationReceiptIds(ticketIds)
  for (const chunk of receiptChunks) {
    const receipts = await expo.getPushNotificationReceiptsAsync(chunk)
    for (const [id, receipt] of Object.entries(receipts)) {
      if (receipt.status === 'ok') continue
      if (receipt.status === 'error') {
        if (receipt.details?.error === 'DeviceNotRegistered') {
          await markTokenInvalid(id)
        }
        console.error(`推送失败（${id}）:`, receipt.message)
      }
    }
  }
}
```

服务端的数据模型建议至少包括 `user_id`、`device_id`、`expo_token`、`platform`、`app_version`、`locale`、`last_seen_at` 等字段。每次应用启动我们都会重新上报 token，并用 `device_id + expo_token` 做幂等写入，避免数据库里出现无穷多的重复记录。当用户在设置里关闭推送或退出登录时，要立刻标记 token 失效；若收到 `DeviceNotRegistered`、`InvalidCredentials` 等错误，也需要同步清理，否则浪费发送额度，还可能引发用户投诉。数据层要兼顾隐私合规，支持应用户请求删除数据。

当需要给几十万用户同时发券时，可靠的队列和限流就是救命稻草。我的实践是：先把所有收件人写入消息队列（**RabbitMQ**/**SQS**/**BullMQ** 均可），消费者进程再按照 Expo 允许的速率发出。SDK 会自动 chunk，但是你仍然应该设置 `maxBatchSize` 和 `maxPerSecond`，并在失败时做指数退避。业务侧最好把营销推送和系统推送拆成不同队列，甚至使用不同的凭证，确保营销活动不会影响交易类消息。

> **Expo** 的限制是上限为每秒 600 个，大多数同学在开发的东西都不会碰到这个上限，所以队列就不是必须的，通知存下库就好啦，但是如果你是一个大规模的应用，可能就需要考虑队列了。

推送与业务系统可以结合的点有三个：

- **模板系统**：把标题、内容、跳转参数抽象成模板，结合数据仓库里的用户标签动态渲染，避免工程化同学天天改文案。
- **多渠道编排**：同一类消息可能同时有短信、邮件、站内信等备选渠道，服务端要根据成本和紧急程度自动选择；Push 一旦失败，可以继续回落到短信。
- **埋点回执**：不仅要记录 `ticketId`、请求体和计划发送时间，还要在客户端点击、打开时上报行为，形成闭环。

## 五、小结

**推送能力** 横跨客户端、服务端与运营，真正打通后，你才能在恰当的时间用恰当的内容重新唤醒用户。借助 **Expo** `expo-notifications` 与 **Expo Push Service**，我们可以在统一抽象之上快速搭建跨平台推送，再通过策略、监控与合规不断打磨体验。
