# 4. 应用内购买（IAP）- 整体IAP生态理解

IAP 是移动商业闭环的关键一环。真正稳定的 IAP 系统不只在“能买”，而在“能验证、能恢复、能审计、能应对边界”。

会有三章内容，第一章讲述最基本IAP的概念，第二章讲Apple Play的支付/订阅体系，第三章讲Google Play的支付/订阅体系。

这三章我的考虑是这样的：业务上的后端实现会有很大差异化，所以不在本文讨论范围内，我会尽量聚焦在生态体系上，当理解整个生态体系之后后端仅仅就只是插哪张表、定时器处理哪个任务、幂等的支付怎么写这种纯代码逻辑问题。

> 我在真实开发这块内容时，最花费的时间点其实就在理解两大生态体系上，这部分的调试也是最痛苦的，跑通生态后的，代码实现其实并不复杂。

## IAP 的地基

我想先回答三个问题：谁在买、买的是什么、这笔钱是怎么被认出来的。只要这三个点够清楚，后面的苹果和谷歌章节就不会显得像黑箱。

![IAP生态全景草图（Google Play 典型集成架构）](https://ik.imagekit.io/ixou4q6nu/overview-arch.svg?updatedAt=1761988437620)

在做 IAP 时，我们很多人都会盯着客户端的购买入口，但真正的主体其实是三角关系：用户、平台商店、我们的服务端。客户端只是用户提交意图的工具。商店负责生成交易凭证，服务端需要用凭证解释和兑现权益。任何一个角的理解不够深，都会在发版后留下坑。

流程是先拿到票据，再去问商店，再让服务端记账，最后才给用户授权。这里的“问商店”指的是服务端拿着票据立刻去请求商店接口校验，客户端在 `purchaseSuccess` 的回调里第一时间把票据 POST 给服务端，然后等服务端返回验证结果。

> 要让这个三角关系真正跑得顺，权限管理和状态同步也得提前规划。服务端最好有一个“订单状态机”，而不是几个散落在各个表里的字段。

## “能买”只是入口票

IAP 看上去是个按钮 + loading 的简单流程，但真正要兜住的是这三类场景：

- 付款成功，权益需要立即兑现；
- 付款成功但客户端断网，要支持恢复；
- 付款失败，钱没扣但我们要给出明确反馈。

客户端负责尽早把票据带回，服务端负责“能验证、能重放、能审计”。如下图：

![IAP异常路径示意（序列图）](https://ik.imagekit.io/ixou4q6nu/rewarded-products-workflow.svg?updatedAt=1761988437473)

服务端这边除了验证，还得考虑如何抵御重复通知。苹果的服务器推送会在没有收到成功响应时重试很多次，谷歌的实时开发者通知也一样。如果服务端的处理流程不是幂等的，就会出现多发权益或把订单状态反复写回的混乱。

## 票据问题

票据（receipt / purchase token）是整个生态里最容易被忽视却最关键的东西。它本质上是商店对这笔交易的签名。我们要盯好三个细节：

1. 票据是一次性还是可重放的（苹果和谷歌不一样）；
2. 票据有没有过期或撤销的状态；
3. 我们的数据库里是否保留了原始票据，以便追溯。

![票据验证流程（App↔Server↔Store 验证）](https://ik.imagekit.io/ixou4q6nu/rvsworkflow._TTH_.png?updatedAt=1761988439388)

要记住：票据和产品配置的绑定关系。很多开发喜欢在客户端本地缓存商品价格和描述，但 Apple 和 Google 都支持远程改价。假设运营当天决定给某个订阅做限时折扣，客户端缓存里还是原来的价格，结果买单成功但是服务端对不上。

价格这件事要彻底交给商店来决定，服务端只对订单中的 `productId` 做解析，不再关心金额，要保证价格一致性。

票据的加密和存储同样重要。最佳实践是把原始票据和校验结果一起存入数据库，同时在对象存储里备份一份。原因很简单：如果未来需要对账或者配合风控调查，原始票据是唯一可信的证据。备份时记得做好访问控制，票据一旦泄露，意味着任何人都可能伪造请求。我们在服务端要求所有票据访问都要经过服务内授权，避免被内部工具直接查到。

## 恢复机制的痛苦

恢复机制是一整套抽屉里的账单。用户换设备、重装、或在断网期间完成了交易，客户端都必须能批量把历史票据拉回来，再交给服务端重新计算。

恢复流程里最隐蔽的环节是“权益回溯”。用户点击恢复后，我们不应该无脑把所有历史权益再次发放，而是要根据票据中的最新状态重新计算。订阅可能已经过期，消耗型商品可能已经使用完，我们得和自家服务的使用记录对齐。

![购买/权益生命周期与通知总览](https://ik.imagekit.io/ixou4q6nu/overview.svg?updatedAt=1761988437708)

## 审计

IAP 的风险往往在上线很久后才暴露。例如：出现异常大量退款但权益未收回、某个版本埋点丢失导致数据追不上。这些都得靠审计体系兜住。我习惯在项目里先搭一个最简单的审计表，把票据、订单状态、权益发放、退款记录、处理人这些关系记录下来，下次查账就不需要跑脚本抓日志。

这一章的目标就是把 IAP 的“全景”讲明白，后面再切换到 Apple 和 Google 的具体规则时，你会知道为什么同一张票据在两个平台上有完全不一样的生命周期。

审计表并不是一开始就得铺得很重，但一定要有最小集合：订单号、票据摘要、金额、币种、购买时间、验证时间、权益发放动作、最后一次状态变更来源。

除了表结构，还要给运营和客服准备几个基础报表：过去 24 小时内的失败订单、最近一周的退款趋势、按支付渠道拆分的成功率。这些数据都能从审计表里拉出来，但需要有人负责整理。

审计中的另一个难点是处理退款和逆向操作。苹果的 App Store Connect 会在退款发生后给你发送通知，谷歌的 Play Console 则需要你自己拉取。

## 梳理落地路线

因为支付整体业务的复杂性实在太高了，对于复杂问题我们需要拆解一下，一步步去完成：

1. **打通最小闭环**：客户端能发起购买，服务端能验证票据并发放权益，日志里能看到完整链路；
2. **加固异常路径**：把超时、重试、断网、票据重复这些情况全部模拟一遍，客户端和服务端都要有兜底策略；
3. **上线恢复机制**：真实账号演练恢复，确保分页、幂等、增量发放逻辑都跑顺；
4. **构建审计体系**：订单状态机、票据备份；
5. **团队共识与文档**：把所有流程、边界、常见问答写成文档，新人在两天内能看懂并跑通沙箱测试。

这种“先让链路跑起来，再把防守点逐个补齐”的方式，开发的整体节奏会比较舒服一点（硬写真的非常烦，问题太多了）。

审计体系是属于可以后搭的，有审计体系，后面扩展订阅、打包促销、跨平台互通会更好排查数据流。

那么下一章我们就先讲Apple的IAP生态体系。
