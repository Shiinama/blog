# 5. 终极扩展：原生模块开发（Bare / 托管 + 插件）

当现有模块无法覆盖你的需求（例如特殊传感器访问、企业级安全 SDK、定制编解码器、厂商私有硬件协议），原生扩展便是你的王牌。Expo 提供了两条路径：在托管工作流中用 Expo Modules + Config Plugins + Dev Build 完成 80% 的原生扩展；或转向 Bare，获得对原生工程 100% 的掌控。本章给出两条路线的实战骨架、最佳实践与排错清单，帮助你既快又稳地落地原生能力。

## 一、路线 A：托管 + Expo Modules + Config Plugins + Dev Build

适用场景：

- 希望保留 EAS（构建、提交、更新）与 OTA 的优势；
- 原生改动以“配置与初始化”为主（权限、Manifest、InfoPlist、Gradle）；
- 能够用 Expo Modules API 组织模块的生命周期与导出函数。

关键组件：

- Expo Modules：在 iOS/Android 暴露 JS 可调用的原生方法与事件；
- Config Plugins：在构建前对原生工程做“声明式修改”；
- Dev Build：包含你的原生依赖的开发客户端，用于真机调试与联调。

1）iOS（Swift）模块骨架：

```swift
// ios/MyModule.swift
import ExpoModulesCore

public class MyModule: Module {
  public func definition() -> ModuleDefinition {
    Name("MyModule")

    Function("multiply") { (a: Double, b: Double) -> Double in a * b }

    AsyncFunction("heavyTask") { (payload: String) in
      // 执行耗时任务，注意线程切换
      return "OK: \(payload)"
    }

    Events("onStateChange")
  }
}
```

2）Android（Kotlin）模块骨架：

```kotlin
// android/src/main/java/com/company/mymodule/MyModule.kt
package com.company.mymodule

import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition

class MyModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("MyModule")

    Function("multiply") { a: Double, b: Double -> a * b }

    AsyncFunction("heavyTask") { payload: String ->
      // 线程模型由 Expo Modules 管理，避免阻塞 UI 线程
      "OK: $payload"
    }

    Events("onStateChange")
  }
}
```

3）JS 侧调用与事件：

```ts
import { requireNativeModule, EventEmitter } from 'expo-modules-core'

type TMyModule = { multiply(a: number, b: number): number; heavyTask(payload: string): Promise<string> }
const MyModule = requireNativeModule<TMyModule>('MyModule')

export const emitter = new EventEmitter(MyModule as any)
emitter.addListener('onStateChange', (s) => console.log('State:', s))

MyModule.multiply(2, 3)
await MyModule.heavyTask('payload')
```

4）Config Plugin（`app.plugin.ts`）：

```ts
import { withInfoPlist, withAndroidManifest, ConfigPlugin } from '@expo/config-plugins'

const withMyModule: ConfigPlugin<{ cameraUsage?: string }> = (config, props) => {
  config = withInfoPlist(config, (c) => {
    c.modResults.NSCameraUsageDescription = props.cameraUsage ?? '需要相机用于扫描'
    return c
  })

  config = withAndroidManifest(config, (c) => {
    const manifest = c.modResults
    // 在此添加权限、Service、Provider 或 Intent-Filter
    // 例如：相机权限、文件 Provider、前台 Service 等
    return c
  })
  return config
}

export default withMyModule
```

在 `app.config.ts` 引入：

```ts
plugins: [["./app.plugin", { cameraUsage: "用于扫码登录" }]]
```

调试：

```bash
eas build --profile development --platform ios
```

最佳实践：

- 把“手工改 Info.plist/Manifest”的步骤固化为插件；
- 导出 API 以 Promise/事件为主，避免回调地狱；
- 对敏感权限统一从 JS 层触发检查与申请；
- 模块内加入最小化日志，便于线上排查。

## 二、路线 B：Bare 工作流（完全掌控）

适用场景：

- 与既有原生工程深度融合；
- 复杂第三方 SDK（自定义编译器、AAR/Static libs、SwiftPM/Pods 混用等）；
- 自研平台层能力（多媒体编解码、底层网络/蓝牙栈）。

迁移：

```bash
npx expo prebuild
```

迁移后建议：

- 保留 Config Plugins：即便 Bare，也可继续使用插件做“声明式修改”，提升可维护性；
- 编译配置分层：区分 Debug/Release、Staging/Production，显式写入凭证与开关；
- E2E 与崩溃分析：在原生层加入 Crashlytics/Sentry 原生 SDK；
- 代码组织：iOS 用 SwiftPM+CocoaPods 组合，Android 用 Gradle 子模块化，避免巨石工程。

第三方库集成要点：

- iOS：配置 `Podfile` 与 `Info.plist`，必要时编辑 `Entitlements`（推送/钥匙串/关联域名等）；
- Android：在根/模块级 `build.gradle` 配置仓库与依赖，更新 `AndroidManifest.xml` 权限与 `proguard-rules.pro`；
- 初始化时机：跟随 Application/Activity 生命周期，避免在后台进程初始化导致崩溃；
- 多进程：部分厂商 SDK 会启多进程服务，注意数据同步与 IPC。

## 三、API 设计与稳定性

- 幂等与错误边界：每个导出方法都要定义失败类型与恢复策略；
- 线程模型：重任务放到后台线程，UI 更新回到主线程；
- 事件契约：定义清晰、稳定的事件名与负载结构，避免后续破坏性变更；
- 版本兼容：对外发布时标明最低 Expo SDK/RN 版本，遵循 SemVer；
- 日志与开关：仅在调试或灰度阶段打开详细日志，生产谨慎。

## 四、打包与发布到 npm（可选）

- 跨平台测试矩阵：iOS 15–17、Android 8–14，不同 ABI；
- CI：本地 `pnpm build` + EAS CI 结合，保证示例工程可构建；
- 文档化：README 内明确安装、配置、最小示例与常见问题；
- 版本管理：跟随 Expo SDK 发布节奏对齐依赖范围，避免“锁死版本”。

## 五、常见问题与排查

- `requireNativeModule` 报错：模块名不一致或未正确注册；
- iOS 链接失败：`cd ios && pod install --repo-update`，清理 Derived Data；
- Android 类找不到：检查 `namespace`/`package` 与路径一致，`./gradlew clean` 后重试；
- Dev Build 未包含改动：清理缓存并重建；确保插件已生效；
- 混淆导致崩溃：添加保留规则到 `proguard-rules.pro`。

## 小结

把“原生修改”声明化、模板化、可重复，是降低复杂度的关键。优先以 Expo Modules + Config Plugins + Dev Build 解决 80% 的原生诉求；当确需完全掌控时再转 Bare，并把可重复的动作沉淀为插件与脚本，让工程在复杂中仍可被团队稳定维护。
