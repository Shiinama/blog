---
title: 8.React源码阅读-fiber的强相关总结
description: 这篇文章是关于 React 源码中 fiber 的强相关总结
published: true
toc:
  visible: true
date: 2022-11-21
---
# React源码阅读-fiber的强相关总结



这篇文章是关于 React 源码中 fiber 的强相关总结，包括 Fiber 对象的属性及解释、Update 与 UpdateQueue 对象、双缓存树、构建全局变量、hooks 的相关内容（如数据结构、api 分类、初次构建和更新的不同函数、全局变量），还提出了手写 fiber 的思路。

关联问题: Fiber 如何影响性能？ UpdateQueue 怎样工作？ 双缓存树优势在哪？

AI智能总结首次生成速度较慢, 请耐心等待

# Fiber手写的准备工作

因为`fiber`是核心, react 体系的渲染和更新都要以 fiber 作为数据模型, 如果不能理解 fiber, 也无法深入理解react。但事实上如果说想了解fiber是个很残酷的事情,因为这意味着你要理解`react-reconciler`(协调器)、同时也要知道一些`react-dom`（渲染器）和`scheduler`（调度中心）的事情。

所以想了一下我们需要先做一些抽离把一些跟fiber强相关的东西先拿出来说一下。（这篇是属于总结篇，就是阅读到哪部分都拿到这里）。

## 1.fiber对象

```typescript
// 一个Fiber对象代表一个即将渲染或者已经渲染的组件(ReactElement), 一个组件可能对应两个fiber(current和WorkInProgress)
export type Fiber = {|
  tag: WorkTag,
  key: null | string,
  elementType: any,
  type: any,
  stateNode: any,
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,
  index: number,
  ref:
    | null
    | (((handle: mixed) => void) & { _stringRef: ?string, ... })
    | RefObject,
  pendingProps: any, // 从`ReactElement`对象传入的 props. 用于和`fiber.memoizedProps`比较可以得出属性是否变动
  memoizedProps: any, // 上一次生成子节点时用到的属性, 生成子节点之后保持在内存中
  updateQueue: mixed, // 存储state更新的队列, 当前节点的state改动之后, 都会创建一个update对象添加到这个队列中.
  memoizedState: any, // 用于输出的state, 最终渲染所使用的state
  dependencies: Dependencies | null, // 该fiber节点所依赖的(contexts, events)等
  mode: TypeOfMode, // 二进制位Bitfield,继承至父节点,影响本fiber节点及其子树中所有节点. 与react应用的运行模式有关(有ConcurrentMode, BlockingMode, NoMode等选项).

  // Effect 副作用相关
  flags: Flags, // 标志位
  subtreeFlags: Flags, //替代16.x版本中的 firstEffect, nextEffect. 当设置了 enableNewReconciler=true才会启用
  deletions: Array<Fiber> | null, // 存储将要被删除的子节点. 当设置了 enableNewReconciler=true才会启用

  nextEffect: Fiber | null, // 单向链表, 指向下一个有副作用的fiber节点
  firstEffect: Fiber | null, // 指向副作用链表中的第一个fiber节点
  lastEffect: Fiber | null, // 指向副作用链表中的最后一个fiber节点

  // 优先级相关
  lanes: Lanes, // 本fiber节点的优先级
  childLanes: Lanes, // 子节点的优先级
  alternate: Fiber | null, // 指向内存中的另一个fiber, 每个被更新过fiber节点在内存中都是成对出现(current和workInProgress)

  // 性能统计相关(开启enableProfilerTimer后才会统计)
  // react-dev-tool会根据这些时间统计来评估性能
  actualDuration?: number, // 本次更新过程, 本节点以及子树所消耗的总时间
  actualStartTime?: number, // 标记本fiber节点开始构建的时间
  selfBaseDuration?: number, // 用于最近一次生成本fiber节点所消耗的时间
  treeBaseDuration?: number, // 生成子树所消耗的时间的总和
|};

```

属性解释:

* `fiber.tag`: 表示 fiber 类型, 根据`ReactElement`组件的 type 进行生成, 在 react 内部共定义了[25 种 tag](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactWorkTags.js%23L10-L35 "https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactWorkTags.js#L10-L35").
* `fiber.key`: 和`ReactElement`组件的 key 一致.
* `fiber.elementType`: 一般来讲和`ReactElement`组件的 type 一致
* `fiber.type`: 一般来讲和`fiber.elementType`一致. 一些特殊情形下, 比如在开发环境下为了兼容热更新(`HotReloading`), 会对`function, class, ForwardRef`类型的`ReactElement`做一定的处理, 这种情况会区别于`fiber.elementType`, 具体赋值关系可以查看[源文件](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiber.old.js%23L571-L574 "https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiber.old.js#L571-L574").
* `fiber.stateNode`: 与`fiber`关联的局部状态节点(比如: `HostComponent`类型指向与`fiber`节点对应的 dom 节点; 根节点`fiber.stateNode`指向的是`FiberRoot`; class 类型节点其`stateNode`指向的是 class 实例).
* `fiber.return`: 指向父节点.
* `fiber.child`: 指向第一个子节点.
* `fiber.sibling`: 指向下一个兄弟节点.
* `fiber.index`: fiber 在兄弟节点中的索引, 如果是单节点默认为 0.
* `fiber.ref`: 指向在`ReactElement`组件上设置的 ref(`string`类型的`ref`除外, 这种类型的`ref`已经不推荐使用, `reconciler`阶段会`将string`类型的`ref`转换成一个`function`类型).
* `fiber.pendingProps`: 输入属性, 从`ReactElement`对象传入的 props. 用于和`fiber.memoizedProps`比较可以得出属性是否变动.
* `fiber.memoizedProps`: 上一次生成子节点时用到的属性, 生成子节点之后保持在内存中. 向下生成子节点之前叫做`pendingProps`, 生成子节点之后会把`pendingProps`赋值给`memoizedProps`用于下一次比较.`pendingProps`和`memoizedProps`比较可以得出属性是否变动.
* `fiber.updateQueue`: 存储`update更新对象`的队列, 每一次发起更新, 都需要在该队列上创建一个`update对象`.
* `fiber.memoizedState`: 上一次生成子节点之后保持在内存中的局部状态.
* `fiber.dependencies`: 该 fiber 节点所依赖的(contexts, events)等, 在`context`机制章节详细说明.
* `fiber.mode`: 二进制位 Bitfield,继承至父节点,影响本 fiber 节点及其子树中所有节点. 与 react 应用的运行模式有关(有 ConcurrentMode, BlockingMode, NoMode 等选项).
* `fiber.flags`: 标志位, 副作用标记(在 16.x 版本中叫做`effectTag`, 相应[pr](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fpull%2F19755 "https://github.com/facebook/react/pull/19755")), 在[`ReactFiberFlags.js`](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiberFlags.js%23L10-L41 "https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiberFlags.js#L10-L41")中定义了所有的标志位. `reconciler`阶段会将所有拥有`flags`标记的节点添加到副作用链表中, 等待 commit 阶段的处理.
* `fiber.subtreeFlags`: 替代 16.x 版本中的 firstEffect, nextEffect. 默认未开启, 当设置了[enableNewReconciler=true](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Fshared%2FReactFeatureFlags.js%23L93 "https://github.com/facebook/react/blob/v17.0.2/packages/shared/ReactFeatureFlags.js#L93") 才会启用, 本系列只跟踪稳定版的代码, 未来版本不会深入解读, [使用示例见源码](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactFiberCompleteWork.new.js%23L690-L714 "https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L690-L714").
* `fiber.deletions`: 存储将要被删除的子节点. 默认未开启, 当设置了[enableNewReconciler=true](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Fshared%2FReactFeatureFlags.js%23L93 "https://github.com/facebook/react/blob/v17.0.2/packages/shared/ReactFeatureFlags.js#L93") 才会启用, 本系列只跟踪稳定版的代码, 未来版本不会深入解读, [使用示例见源码](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactChildFiber.new.js%23L275-L287 "https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.new.js#L275-L287").
* `fiber.nextEffect`: 单向链表, 指向下一个有副作用的 fiber 节点.
* `fiber.firstEffect`: 指向副作用链表中的第一个 fiber 节点.
* `fiber.lastEffect`: 指向副作用链表中的最后一个 fiber 节点.
* `fiber.lanes`: 本 fiber 节点所属的优先级, 创建 fiber 的时候设置.
* `fiber.childLanes`: 子节点所属的优先级.
* `fiber.alternate`: 指向内存中的另一个 fiber, 每个被更新过 fiber 节点在内存中都是成对出现(current 和 workInProgress)

## 2\. Update 与 UpdateQueue 对象

在`fiber`对象中有一个属性`fiber.updateQueue`, 是一个链式队列(即使用链表实现的队列存储结构), 后文会根据场景表述成链表或队列.

首先观察`Update`对象的数据结构、

```typescript
export type Update<State> = {|
  eventTime: number, // 发起update事件的时间(17.0.2中作为临时字段, 即将移出)
  lane: Lane, // update所属的优先级

  tag: 0 | 1 | 2 | 3, //
  payload: any, // 载荷, 根据场景可以设置成一个回调函数或者对象
  callback: (() => mixed) | null, // 回调函数

  next: Update<State> | null, // 指向链表中的下一个, 由于UpdateQueue是一个环形链表, 最后一个update.next指向第一个update对象
|};

// =============== UpdateQueue ==============
type SharedQueue<State> = {|
  pending: Update<State> | null,
|};

export type UpdateQueue<State> = {|
  baseState: State,
  firstBaseUpdate: Update<State> | null,
  lastBaseUpdate: Update<State> | null,
  shared: SharedQueue<State>,
  effects: Array<Update<State>> | null,
|};

```

属性解释：

1.  `UpdateQueue`
    
    * `baseState`: 表示此队列的基础 state
    * `firstBaseUpdate`: 指向基础队列的队首
    * `lastBaseUpdate`: 指向基础队列的队尾
    * `shared`: 共享队列
    * `effects`: 用于保存有`callback`回调函数的 update 对象, 在`commit`之后, 会依次调用这里的回调函数.
2.  `SharedQueue`
    
    * `pending`: 指向即将输入的`update`队列. 在`class`组件中调用`setState()`之后, 会将新的 update 对象添加到这个队列中来.
3.  `Update`
    
    * `eventTime`: 发起`update`事件的时间(17.0.2 中作为临时字段, 即将移出)
    * `lane`: `update`所属的优先级
    * `tag`: 表示`update`种类, 共 4 种. [`UpdateState,ReplaceState,ForceUpdate,CaptureUpdate`](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Fblob%2Fv17.0.2%2Fpackages%2Freact-reconciler%2Fsrc%2FReactUpdateQueue.old.js%23L131-L134 "https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactUpdateQueue.old.js#L131-L134")
    * `payload`: 载荷, `update`对象真正需要更新的数据, 可以设置成一个回调函数或者对象.
    * `callback`: 回调函数. `commit`完成之后会调用.
    * `next`: 指向链表中的下一个, 由于`UpdateQueue`是一个环形链表, 最后一个`update.next`指向第一个`update`对象.

## 3.fiber双缓存树

什么是双缓存，就是在内存中直接进行构建然后进行替换的技术。

对应到`React`中，会存在两颗`fiberDom树`，一颗内存中`fiber树`，一颗页面上的`fiber树`，它们总是交替循坏，当更新后，页面上的`fiber树`\->内存中的`fiber树`，内存中的`fiber树` -> 页面上的`fiber`树。

```js
// The root we're working on
let workInProgressRoot: FiberRoot | null = null;
// The fiber we're working on
let workInProgress: Fiber | null = null;

```

## 4.fiber中的构建全局变量

```js
// 执行状态
let executionContext: ExecutionContext = NoContext;
// 页面上的fiber
let workInProgressRoot: FiberRoot | null = null;
// 内存中的fiber
let workInProgress: Fiber | null = null;
// 渲染的车道
let workInProgressRootRenderLanes: Lanes = NoLanes;
// 跟节点的状态是否是已完成，挂起等
let workInProgressRootExitStatus: RootExitStatus = RootIncomplete;

```

## 5.fiber中hooks的强相关

`hooks`中任意的api都是为了直接或者间接控制fiber中的状态

```js
export type Fiber = {|
  // 1. fiber节点自身状态相关
  pendingProps: any,
  memoizedProps: any,
  updateQueue: mixed,
  memoizedState: any,

  // 2. fiber节点副作用(Effect)相关
  flags: Flags,
  nextEffect: Fiber | null,
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,
|};

```

`hooks`数据结构、queue环形链表，只处理hooks中的状态。

```js
type Update<S, A> = {|
  lane: Lane,
  action: A,
  eagerReducer: ((S, A) => S) | null, //最新提交函数
  eagerState: S | null, //最新状态
  next: Update<S, A>,
  priority?: ReactPriorityLevel,
|};

type UpdateQueue<S, A> = {|
  pending: Update<S, A> | null,
  dispatch: (A => mixed) | null,
  lastRenderedReducer: ((S, A) => S) | null, //队尾的提交函数指向到最新的状态
  lastRenderedState: S | null, //最后一次得到的 state
|};

export type Hook = {|
  memoizedState: any, // 当前状态
  baseState: any, // 基础状态
  baseQueue: Update<any, any> | null, // 基队列
  queue: UpdateQueue<any, any> | null, // 更新队列
  next: Hook | null, // next指针
|};


```

`effect.tag`标识符

```js
export const NoFlags = /*  */ 0b000;
export const HasEffect = /* */ 0b001; // 有副作用, 可以被触发
export const Layout = /*    */ 0b010; // 浏览器渲染结束后执行
export const Passive = /*   */ 0b100; // dom更新完成后执行

```

`effect对象`

```js
export type Effect = {|
  tag: HookFlags, //effct的标识符
  create: () => (() => void) | void, //effect的回调函数
  destroy: (() => void) | void, //回调函数中的return,执行销毁，清除副作用函数
  deps: Array<mixed> | null, //依赖项
  next: Effect, //指向下一个effct
|};

```

`hooks` api分类

```js
export type HookType =
  | 'useState'
  | 'useReducer'
  | 'useContext'
  | 'useRef'
  | 'useEffect'
  | 'useLayoutEffect'
  | 'useCallback'
  | 'useMemo'
  | 'useImperativeHandle'
  | 'useDebugValue'
  | 'useDeferredValue'
  | 'useTransition'
  | 'useMutableSource'
  | 'useOpaqueIdentifier';


```

`hooks`初次构建和更新的不同的使用函数

```js
const HooksDispatcherOnMount: Dispatcher = {
  readContext,
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  useDebugValue: mountDebugValue,
  useDeferredValue: mountDeferredValue,
  useTransition: mountTransition,
  useMutableSource: mountMutableSource,
  useOpaqueIdentifier: mountOpaqueIdentifier,
  unstable_isNewReconciler: enableNewReconciler,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  readContext,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  useDebugValue: updateDebugValue,
  useDeferredValue: updateDeferredValue,
  useTransition: updateTransition,
  useMutableSource: updateMutableSource,
  useOpaqueIdentifier: updateOpaqueIdentifier,
  unstable_isNewReconciler: enableNewReconciler,
};

```

`hooks` 全局变量

```js
// 渲染优先级
let renderLanes: Lanes = NoLanes;
// 当前正在构造的fiber, 等同于 workInProgress
let currentlyRenderingFiber: Fiber = (null: any);
// Hooks被存储在fiber.memoizedState 链表上
let currentHook: Hook | null = null; // currentHook = fiber(current).memoizedState
let workInProgressHook: Hook | null = null; // workInProgressHook = fiber(workInProgress).memoizedState
// 在function的执行过程中, 是否再次发起了更新. 只有function被完全执行之后才会重置.
// 当render异常时, 通过该变量可以决定是否清除render过程中的更新.
let didScheduleRenderPhaseUpdate: boolean = false;
// 在本次function的执行过程中, 是否再次发起了更新. 每一次调用function都会被重置
let didScheduleRenderPhaseUpdateDuringThisPass: boolean = false;
// 在本次function的执行过程中, 重新发起更新的最大次数
const RE_RENDER_LIMIT = 25;
// dev模式下，暂不分析
let currentHookNameInDev: ?HookType = null;
let hookTypesDev: Array<HookType> | null = null;
let hookTypesUpdateIndexDev: number = -1;
let ignorePreviousDependencies: boolean = false;

```

## 接下来我们分析一下我们的手写思路

1.  我们需要通过reactElement树去构建一个简单的fiber树。
2.  创建任务队列和实现调度逻辑，创建任务队列对标源码的reconciler（构造器或者说协调器）注册调度任务task。调度逻辑对标源码的scheduler的调度实现，去控制任务的回调时间，然后去实现任务分片以及可中断的特性。
3.  实现简单初始渲染。
4.  实现简单更新渲染。

## 总结

方便我们后面简单实现fiber的时候，做出分析。