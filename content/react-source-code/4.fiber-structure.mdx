---
title: 4. React Fiber链表结构深度解析
description: Fiber是React的核心架构，它使用链表结构来组织和管理组件树。
published: true
toc:
  visible: true
date: 2023-03-05
---

# React Fiber链表结构深度解析

## 1. Fiber结构深入剖析

Fiber是React的核心架构，它使用链表结构来组织和管理组件树。

### 1.1 Fiber节点的结构

每个Fiber节点都是一个复杂的JavaScript对象，包含了组件的各种信息及其与其他节点的关系。以下是Fiber节点的详细结构：

```javascript
{
  // 标记组件类型
  tag: WorkTag,

  // 唯一标识，用于优化更新过程
  key: null | string,

  // 组件的类型（函数组件、类组件等）
  type: any,

  // 对应的DOM节点或组件实例
  stateNode: any,

  // 链表结构
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,

  // 更新相关
  pendingProps: any,
  memoizedProps: any,
  updateQueue: UpdateQueue<any> | null,
  memoizedState: any,

  // 副作用相关
  flags: Flags,
  subtreeFlags: Flags,
  deletions: Array<Fiber> | null,

  // 调度优先级相关
  lanes: Lanes,
  childLanes: Lanes,

  // 替身（用于并发模式）
  alternate: Fiber | null,

  // 开发工具使用
  _debugOwner?: Fiber | null,
  _debugIsCurrentlyTiming?: boolean,
  _debugNeedsRemount?: boolean,

  // 其他属性...
}
```

它主要包含了组件的基本信息，还包括了更新、副作用和调度优先级等重要信息。

### 1.2 Fiber的链表结构

Fiber树使用三个主要指针构建链表结构：

1. `child`: 指向第一个子节点
2. `sibling`: 指向下一个兄弟节点
3. `return`: 指向父节点

我们可以假设我们有以下的React组件结构：

```jsx
<App>
  <Header />
  <Main>
    <Article />
    <Sidebar />
  </Main>
  <Footer />
</App>
```

这个结构可以用Fiber链表表示如下：

```javascript
const App = {
  tag: 'ClassComponent',
  type: App,
  child: Header,
  sibling: null,
  return: null
}

const Header = {
  tag: 'FunctionComponent',
  type: Header,
  child: null,
  sibling: Main,
  return: App
}

const Main = {
  tag: 'FunctionComponent',
  type: Main,
  child: Article,
  sibling: Footer,
  return: App
}

const Article = {
  tag: 'FunctionComponent',
  type: Article,
  child: null,
  sibling: Sidebar,
  return: Main
}

const Sidebar = {
  tag: 'FunctionComponent',
  type: Sidebar,
  child: null,
  sibling: null,
  return: Main
}

const Footer = {
  tag: 'FunctionComponent',
  type: Footer,
  child: null,
  sibling: null,
  return: App
}
```

在这个例子中：

1. `App`的`child`指向`Header`，因为`Header`是`App`的第一个子节点。
2. `Header`的`sibling`指向`Main`，因为`Main`是`Header`的下一个兄弟节点。
3. `Main`的`child`指向`Article`，因为`Article`是`Main`的第一个子节点。
4. `Article`的`sibling`指向`Sidebar`，因为`Sidebar`是`Article`的下一个兄弟节点。
5. 所有节点的`return`都指向它们的父节点。例如，`Header`、`Main`和`Footer`的`return`都指向`App`。

这种结构允许React在树中高效地向上、向下和横向移动，无论是在渲染过程中还是在进行更新时。例如，当React需要更新`Main`组件时，它可以轻松地访问其子组件（通过`child`指针）和兄弟组件（通过`sibling`指针），同时也可以回到父组件（通过`return`指针）。

## 2. Fiber树的构建和更新机制

### 2.1 创建Fiber节点的过程

React使用`createFiberFromElement`函数创建单个Fiber节点:

```javascript
function createFiberFromElement(element, mode, lanes) {
  let owner = null
  if (__DEV__) {
    owner = element._owner
  }
  const type = element.type
  const key = element.key
  const pendingProps = element.props
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes)
  if (__DEV__) {
    fiber._debugSource = element._source
    fiber._debugOwner = element._owner
  }
  return fiber
}
```

这个函数创建了Fiber节点。它调用了`createFiberFromTypeAndProps`来实际创建Fiber对象，这个函数会根据组件的类型（如函数组件、类组件、宿主组件等）创建不同的Fiber节点。

### 2.2 构建Fiber树的过程

`reconcileChildFibers`函数是构建和更新Fiber树的核心:

```javascript
function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
  // 处理不同类型的子节点（单个元素、数组等）
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes))
      case REACT_PORTAL_TYPE:
        return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes))
      case REACT_LAZY_TYPE:
        const payload = newChild._payload
        const init = newChild._init
        return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes)
    }

    if (isArray(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes)
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes)
    }
  }

  // 处理文本节点
  if (typeof newChild === 'string' || typeof newChild === 'number') {
    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes))
  }

  // 处理其他情况（如null，undefined等）
  return deleteRemainingChildren(returnFiber, currentFirstChild)
}
```

这个函数主要是处理不同类型的子节点，包括单个元素、数组、迭代器、文本节点等。

### 2.3 链接Fiber节点的详细过程

在构建过程中，React通过设置`child`、`sibling`和`return`属性来链接Fiber节点。

```javascript
function appendAllChildren(parent, workInProgress) {
  let node = workInProgress.child
  while (node !== null) {
    if (node.tag === HostComponent || node.tag === HostText) {
      appendInitialChild(parent.stateNode, node.stateNode)
    } else if (node.tag === HostPortal) {
      // 不要遍历到portal的子节点
    } else if (node.child !== null) {
      node.child.return = node
      node = node.child
      continue
    }
    if (node === workInProgress) {
      return
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return
      }
      node = node.return
    }
    node.sibling.return = node.return
    node = node.sibling
  }
}
```

这个函数展示了React如何深度优先遍历Fiber树，并在过程中建立正确的父子和兄弟关系。它还处理了特殊情况，如portal组件。

### 2.4 实际例子

让我们以一个简单的React组件树为例:

```jsx
function App() {
  return (
    <div>
      <Header />
      <Main>
        <Article />
        <Sidebar />
      </Main>
      <Footer />
    </div>
  )
}
```

现在,我们来看看React如何使用`reconcileChildFibers`函数来构建这个组件树的Fiber结构:

1. 首先,React会为`App`组件创建一个Fiber节点。

2. 然后,React会调用`reconcileChildFibers`来处理`App`的子元素(即`div`):

   ```javascript
   reconcileChildFibers(appFiber, null, <div>...</div>, lanes)
   ```

3. 在`reconcileChildFibers`中,React会识别出这是一个`REACT_ELEMENT_TYPE`,然后调用`reconcileSingleElement`:

   ```javascript
   case REACT_ELEMENT_TYPE:
     return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes))
   ```

4. `reconcileSingleElement`会创建一个新的Fiber节点表示`div`,并将其设置为`App` Fiber的child。

5. 接下来,React会再次调用`reconcileChildFibers`来处理`div`的子元素:

   ```javascript
   reconcileChildFibers(divFiber, null, [<Header />, <Main>...</Main>, <Footer />], lanes)
   ```

6. 这次,因为子元素是一个数组,React会进入`isArray(newChild)`的分支:

   ```javascript
   if (isArray(newChild)) {
     return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes)
   }
   ```

7. 在`reconcileChildrenArray`中,React会为`Header`、`Main`和`Footer`各创建一个Fiber节点,并将它们链接起来形成一个兄弟链表。

8. 对于`Main`组件,React会再次调用`reconcileChildFibers`来处理其子元素:

   ```javascript
   reconcileChildFibers(mainFiber, null, [<Article />, <Sidebar />], lanes)
   ```

9. 同样,这会创建`Article`和`Sidebar`的Fiber节点,并将它们链接为兄弟节点。

通过这个过程,React最终会构建出如下的Fiber树结构:

```
App
 |
 +-- div
      |
      +-- Header
      |
      +-- Main
      |    |
      |    +-- Article
      |    |
      |    +-- Sidebar
      |
      +-- Footer
```

在这个结构中:

- 每个节点都是一个Fiber对象
- 父子关系通过`child`和`return`指针维护
- 兄弟关系通过`sibling`指针维护

## 3. Fiber链表查找

这一节主要讲链表查找，然后我思考了一下时间复杂度和传统树算法差不多，但空间复杂度大大减小了且对于gc回收的话只需要断裂链表。

然后另外一个考虑应该就是，链表结构使得遍历可以在任意点暂停和恢复，这其实是React实现时间切片的基础。

### 3.1 向下查找特定类型的子节点

有时我们需要查找特定类型的子节点，例如查找第一个类组件：

```javascript
function findFirstClassComponent(fiber) {
  let child = fiber.child
  while (child !== null) {
    if (child.tag === ClassComponent) {
      return child
    }
    if (child.tag === HostComponent || child.tag === HostText) {
      // 跳过宿主组件
      child = child.sibling
    } else {
      // 继续向下查找
      const result = findFirstClassComponent(child)
      if (result !== null) {
        return result
      }
      child = child.sibling
    }
  }
  return null
}
```

### 3.2 向上查找特定条件的祖先节点

在某些情况下，我们需要向上查找满足特定条件的祖先节点，例如查找最近的Provider组件：

```javascript
function findNearestProvider(fiber, contextType) {
  let current = fiber.return
  while (current !== null) {
    if (current.tag === Provider && current.type._context === contextType) {
      return current
    }
    current = current.return
  }
  return null
}
```

### 3.3 复杂的树遍历操作

有时我们需要进行更复杂的树遍历操作，例如同时向上和向下查找：

```javascript
function findNodeBetween(start, end, predicate) {
  let current = start
  while (current !== null && current !== end) {
    if (predicate(current)) {
      return current
    }
    if (current.child !== null) {
      current = current.child
    } else {
      while (current !== null && current !== end) {
        if (current.sibling !== null) {
          current = current.sibling
          break
        }
        current = current.return
      }
    }
  }
  return null
}
```

## 4. 实际意义

理解fiber的结构能帮助我们去理解上层组件结构、避免嵌套、以及思考怎样的组件设计是最优解的性能这种问题，而不是漫无目的的有组件就套就写就好了。

**示例 1：深度嵌套的结构**

```jsx
const DeeplyNestedPage = () => (
  <div>
    <Header>
      <Navigation>
        <NavItem>Home</NavItem>
        <NavItem>About</NavItem>
        <NavItem>Contact</NavItem>
      </Navigation>
    </Header>
    <Content>
      <Sidebar>
        <SidebarItem>Item 1</SidebarItem>
        <SidebarItem>Item 2</SidebarItem>
      </Sidebar>
      <MainContent>
        <Article>
          <Title>Welcome</Title>
          <Paragraph>This is the main content.</Paragraph>
        </Article>
      </MainContent>
    </Content>
    <Footer>
      <Copyright>© 2023</Copyright>
    </Footer>
  </div>
)
```

**示例 2：扁平化的结构**

```jsx
const FlatPage = () => (
  <div>
    <Header />
    <Navigation />
    <NavItem>Home</NavItem>
    <NavItem>About</NavItem>
    <NavItem>Contact</NavItem>
    <Content />
    <Sidebar />
    <SidebarItem>Item 1</SidebarItem>
    <SidebarItem>Item 2</SidebarItem>
    <MainContent />
    <Article />
    <Title>Welcome</Title>
    <Paragraph>This is the main content.</Paragraph>
    <Footer />
    <Copyright>© 2023</Copyright>
  </div>
)
```

这两个例子最终都能达成相同的功能，但实现结构是不同的，我们可以分析一下这两种结构对 Fiber 树和性能的影响：

1. **Fiber 树的深度**：

   - 深度嵌套的结构会创建一个更深的 Fiber 树。每一层嵌套都会在 Fiber 树中增加一个层级。
   - 扁平化的结构创建的 Fiber 树更浅，大多数组件都是直接的子组件。

2. **更新效率**：

   - 在深度嵌套的结构中，如果顶层组件（如 `Header`）发生变化，React 需要遍历更多的 Fiber 节点来确定需要更新的内容。
   - 扁平化的结构使得 React 可以更快地定位到需要更新的组件，因为它们大多处于同一层级。

3. **组件复用和状态管理**：

   - 深度嵌套的结构其实经常会导致不必要的组件重渲染。例如，如果 `Content` 组件的状态改变，它可能会导致 `Sidebar` 和 `MainContent` 都重新渲染。
   - 而扁平化的结构允许更精确的控制哪些组件需要重新渲染。

4. **代码可维护性**：

   - 显然扁平化的结构通常更容易维护和重构，因为组件之间的依赖关系更清晰。

5. **性能优化空间**：
   - 扁平化的结构也更好优化。
