---
title: 3.React调度核心原理（补）
description: 深入探讨React的调度机制，解析其核心原理，并与requestIdleCallback API进行对比，揭示React如何实现高效的任务调度。
published: true
toc:
  visible: true
date: 2023-01-10
---

# React调度核心原理及其与requestIdleCallback的关系

在深入探讨 React 的 Fiber 架构之前，我们需要先了解 `requestIdleCallback` 这个 API。它允许我们在浏览器空闲时执行低优先级的任务，从而不影响高优先级任务的执行。这个 API 帮助我们理解"空闲时间"和"让出主线程"的概念。

> 25年1月31日穿越发言: 这文章我稍微修了一下，发现了个大问题就是只看这一段调度机制单独拿出来几乎是看不懂的，但不会大修了，而且现在react19了，它的调度机制加入了非常多的内容，可能在很长一段时间我也等着别人分析投喂我一下，有看到好的文章的小伙伴可以滴我一下。

## 1. requestIdleCallback 简介

**空闲时间**：页面渲染是以帧为单位的，流畅的页面通常保持 60 帧/秒，即每帧约 16ms。如果每帧的执行时间少于 16ms，剩余的时间就是空闲时间。

**API 介绍**：

![requestIdleCallback API](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f056b718c9f485e92119ad1ea1666a5~tplv-k3u1fbpfcp-watermark.image?)

- 返回值 `2` 是回调的 ID，可用于 `Window.cancelIdleCallback()` 方法来取消回调。
- `didTimeout` 是一个布尔值，当为 `true` 时表示回调正在执行。
- `timeRemaining()` 方法返回当前帧剩余的空闲时间。

## 2. requestIdleCallback 实战示例

让我们通过两个对比示例来理解 `requestIdleCallback` 的实际应用。

### 2.1 不使用 requestIdleCallback

在这个例子中，我们先模拟一个耗时的计算任务，同时尝试响应用户输入：

```javascript
const button = document.getElementById('button')
const input = document.getElementById('input')
let isPrimeNumber = true

button.addEventListener('click', () => {
  // 模拟耗时计算
  for (let i = 2; i < 1000000000; i++) {
    isPrimeNumber = true
    for (let j = 2; j < i; j++) {
      if (i % j === 0) {
        isPrimeNumber = false
        break
      }
    }
  }
  console.log('计算完成')
})

input.addEventListener('input', () => {
  console.log('输入值：', input.value)
})
```

在这个例子中，当用户点击按钮时，会启动一个耗时的计算。在计算过程中，如果用户尝试在输入框中输入内容，会发现输入非常卡顿，甚至完全无响应，直到计算完成。

### 2.2 使用 requestIdleCallback

现在，让我们使用 `requestIdleCallback` 来改进这个例子：

```javascript
const button = document.getElementById('button')
const input = document.getElementById('input')
let isPrimeNumber = true
let i = 2

button.addEventListener('click', () => {
  function doWork(deadline) {
    while (i < 1000000000 && deadline.timeRemaining() > 0) {
      isPrimeNumber = true
      for (let j = 2; j < i; j++) {
        if (i % j === 0) {
          isPrimeNumber = false
          break
        }
      }
      i++
    }

    if (i < 1000000000) {
      requestIdleCallback(doWork)
    } else {
      console.log('计算完成')
    }
  }

  requestIdleCallback(doWork)
})

input.addEventListener('input', () => {
  console.log('输入值：', input.value)
})
```

在这个改进的版本中，我们将耗时的计算任务分割成多个小任务，并使用 `requestIdleCallback` 在浏览器空闲时执行这些任务。这样，即使在进行大量计算的同时，用户仍然可以流畅地在输入框中输入内容，因为浏览器有机会在计算任务之间处理用户输入。

这个例子更好地展示了 `requestIdleCallback` 的核心优势：它允许我们在不阻塞主线程的情况下执行耗时的任务，从而提高应用的响应性和用户体验。

通过这种方式，我们可以更清楚地看到 `requestIdleCallback` 如何帮助我们在执行耗时任务的同时保持应用的响应性，这正是 React 在其调度系统中试图实现的目标。

## 3. React 中的调度实现

虽然 `requestIdleCallback` 展示了空闲时间和让出主线程的概念，但 React 实际上并不使用它来实现调度。关于 React 为什么不使用 `requestIdleCallback`，可以参考[这篇文章](https://juejin.cn/post/7170095557443551246)。而完整的调度实现分为了两个部分。

### 3.1 React 调度源码实现

React 使用 `MessageChannel` 来实现消息的发送和接收，从而实现调度。这种实现可以分为两个核心部分：调度和时间切片。

![React Scheduling Implementation](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8378f03e4c04475391ddb76895a8b505~tplv-k3u1fbpfcp-zoom-1.image)

在我们开始之前先粗略的阅读这段源码：

```javascript
let scheduledHostCallback = null
let taskTimeoutID = -1

let yieldInterval = 5
let deadline = 0

// TODO: Make this configurable
// TODO: Adjust this based on priority?
const maxYieldInterval = 300
let needsPaint = false
if (
  enableIsInputPending &&
  navigator !== undefined &&
  navigator.scheduling !== undefined &&
  navigator.scheduling.isInputPending !== undefined
) {
  const scheduling = navigator.scheduling
  // 17.02的源码这里比较简单，其实这都不用看直接看false,因为enableIsInputPending为false,就而且17.2里面isInputPending是不可以用的，我们直接看18把，然后我就发现18里面好像依然没解决这个问题
  shouldYieldToHost = function () {
    const currentTime = getCurrentTime()
    if (currentTime >= deadline) {
      // 简单的说就是长时间阻塞主线程的东西就给它打断了，绘制（交互）和用户输入之类的东西就给他打断了，都不是我们可以在最大延时里再看看
      if (needsPaint || scheduling.isInputPending()) {
        // There is either a pending paint or a pending input.
        return true
      }
      // 300ms最大延时打断
      return currentTime >= maxYieldInterval
    } else {
      // 不需要打断
      return false
    }
  }

  requestPaint = function () {
    needsPaint = true
  }
} else {
  // 直接看这里这个deadline是在performWorkUntilDeadline执行任务的时候去设置的
  shouldYieldToHost = function () {
    return getCurrentTime() >= deadline
  }

  // Since we yield every frame regardless, `requestPaint` has no effect.
  requestPaint = function () {}
}
// 强制设置检测时间，源码没用到调试的时候可以设置,电脑越好，fps越高分片时间越短
forceFrameRate = function (fps) {
  if (fps < 0 || fps > 125) {
    // Using console['error'] to evade Babel and ESLint
    console['error'](
      'forceFrameRate takes a positive int between 0 and 125, ' +
        'forcing frame rates higher than 125 fps is not supported'
    )
    return
  }
  if (fps > 0) {
    yieldInterval = Math.floor(1000 / fps)
  } else {
    // reset the framerate
    yieldInterval = 5
  }
}

const performWorkUntilDeadline = () => {
  // 有执行任务
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime()
    // 计算一帧的打断检测时间
    deadline = currentTime + yieldInterval
    const hasTimeRemaining = true
    try {
      // 执行c回调
      const hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime)
      // 执行完该回调后, 判断后续是否还有其他任务
      if (!hasMoreWork) {
        isMessageLoopRunning = false
        scheduledHostCallback = null
      } else {
        // 还有其他任务, 推进进入下一个宏任务队列中
        port.postMessage(null)
      }
    } catch (error) {
      // If a scheduler task throws, exit the current browser task so the
      // error can be observed.
      port.postMessage(null)
      throw error
    }
  } else {
    isMessageLoopRunning = false
  }
  // Yielding to the browser will give it a chance to paint, so we can
  // reset this.
  // 重置状态
  needsPaint = false
}

const channel = new MessageChannel()
// port2 发送
const port = channel.port2
// port1 接收
channel.port1.onmessage = performWorkUntilDeadline
// 在每一帧中执行任务
requestHostCallback = function (callback) {
  // 回调注册
  scheduledHostCallback = callback
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true
    // 进入宏任务队列
    port.postMessage(null)
  }
}
// 取消回调
cancelHostCallback = function () {
  scheduledHostCallback = null
}
// 设置超时回调
requestHostTimeout = function (callback, ms) {
  taskTimeoutID = setTimeout(() => {
    callback(getCurrentTime())
  }, ms)
}
// 取消超时
cancelHostTimeout = function () {
  clearTimeout(taskTimeoutID)
  taskTimeoutID = -1
}
```

#### 1. 调度机制

React 通过 `MessageChannel` 建立通道，一个端口发送消息，另一个接收消息。主要代码如下：

```javascript
const channel = new MessageChannel()
const port = channel.port2
channel.port1.onmessage = performWorkUntilDeadline

requestHostCallback = function (callback) {
  scheduledHostCallback = callback
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true
    port.postMessage(null)
  }
}
```

这里，`performWorkUntilDeadline` 函数在接收消息时被调用，它负责设置空闲时间 `deadline` 并执行回调函数。

#### 2. 时间切片

React 通过 `shouldYieldToHost` 函数根据 `deadline` 决定是否中断构建，实现时间切片：

```javascript
shouldYieldToHost = function () {
  return getCurrentTime() >= deadline
}

const performWorkUntilDeadline = () => {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime()
    deadline = currentTime + yieldInterval
    const hasTimeRemaining = true
    try {
      const hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime)
      if (!hasMoreWork) {
        isMessageLoopRunning = false
        scheduledHostCallback = null
      } else {
        port.postMessage(null)
      }
    } catch (error) {
      port.postMessage(null)
      throw error
    }
  } else {
    isMessageLoopRunning = false
  }
  needsPaint = false
}
```

这种实现允许 React 在执行任务时能够及时响应用户交互，提高应用的性能和用户体验。

通过这种方式，React 实现了高效的任务调度和时间切片，使得复杂的渲染过程能够被分割成小块，在不同的时间片段内执行，从而避免长时间阻塞主线程。

### 3.2 setTimeout 降级实现

React 的调度系统设计考虑了不同的运行环境，包括非浏览器环境。React使用了降级策略，使用 `setTimeout` 来模拟类似的调度行为。

降级实现：

1. **环境检测**：
   React 首先检查当前环境是否支持 `window` 对象和 `MessageChannel`。如果不支持，就会启用降级策略。

2. **核心功能模拟**：

   - `_flushCallback`: 模拟了主要的调度逻辑，执行回调并处理异常。
   - `requestHostCallback`: 安排回调的执行，防止重入。
   - `cancelHostCallback`: 取消已安排的回调。
   - `requestHostTimeout` 和 `cancelHostTimeout`: 处理超时逻辑。
   - `shouldYieldToHost`: 在降级模式下始终返回 `false`，意味着任务不会主动让出控制权。

```javascript
if (
  typeof window === 'undefined' ||
  // Check if MessageChannel is supported, too.
  typeof MessageChannel !== 'function'
) {
  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
  // fallback to a naive implementation.
  let _callback = null;
  let _timeoutID = null;
  const _flushCallback = function() {
    if (_callback !== null) {
      try {
        const currentTime = getCurrentTime();
        const hasRemainingTime = true;
        _callback(hasRemainingTime, currentTime);
        _callback = null;
      } catch (e) {
        setTimeout(_flushCallback, 0);
        throw e;
      }
    }
  };
  requestHostCallback = function(cb) {
    if (_callback !== null) {
      // Protect against re-entrancy.
      setTimeout(requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0);
    }
  };
  cancelHostCallback = function() {
    _callback = null;
  };
  requestHostTimeout = function(cb, ms) {
    _timeoutID = setTimeout(cb, ms);
  };
  cancelHostTimeout = function() {
    clearTimeout(_timeoutID);
  };
  shouldYieldToHost = function() {
    return false;
  };
  requestPaint = forceFrameRate = function() {};
} else {
  // Capture local references to native APIs, in case a polyfill overrides them.
  const setTimeout = window.setTimeout;
  const clearTimeout = window.clearTimeout;

  if (typeof console !== 'undefined') {
    // TODO: Scheduler no longer requires these methods to be polyfilled. But
    // maybe we want to continue warning if they don't exist, to preserve the
    // option to rely on it in the future?
    const requestAnimationFrame = window.requestAnimationFrame;
    const cancelAnimationFrame = window.cancelAnimationFrame;

    if (typeof requestAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error'](
        "This browser doesn't support requestAnimationFrame. " +
          'Make sure that you load a ' +
          'polyfill in older browsers. https://reactjs.org/link/react-polyfills',
      );
    }
    if (typeof cancelAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error'](
        "This browser doesn't support cancelAnimationFrame. " +
          'Make sure that you load a ' +
          'polyfill in older browsers. https://reactjs.org/link/react-polyfills',
      );
    }
  }
```
