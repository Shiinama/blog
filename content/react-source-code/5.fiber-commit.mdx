---
title: 5.React Fiber对象的创建与更新
description: 深入探讨React Fiber架构中Fiber对象的创建过程、初始化提交以及Fiber树的更新机制,揭示React内部工作原理。
published: true
toc:
  visible: true
date: 2023-03-09
---

# React Fiber对象的创建与更新机制

在上一篇文章中，我们详细讨论了Fiber的整体结构和链表。本文将深入探讨Fiber对象的创建过程、初始化提交以及Fiber树的更新机制。本节`react`版本18.3（新写的文章就不用看老版本了一样的）。

## 1. 创建Fiber对象

Fiber对象的创建是React渲染过程的起点。当我们调用`ReactDOM.createRoot().render()`时，React开始创建Fiber树。

### 1.1 创建RootFiber

首先，React会创建一个RootFiber，它是整个Fiber树的根节点。

```javascript
function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
  const root = new FiberRootNode(containerInfo, tag, hydrate)
  const uninitializedFiber = createHostRootFiber(tag)
  root.current = uninitializedFiber
  uninitializedFiber.stateNode = root
  initializeUpdateQueue(uninitializedFiber)
  return root
}
```

这个函数创建了FiberRoot和RootFiber。FiberRoot是整个应用的起点，而RootFiber则是组件树的根节点。

### 1.2 创建子Fiber节点

接下来，React会根据组件树递归地创建子Fiber节点。这个过程发生在`reconcileChildren`函数中：

```javascript
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes)
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes)
  }
}
```

`mountChildFibers`和`reconcileChildFibers`都是`ChildReconciler`函数的返回值，它们的区别在于是否标记副作用。

### 1.3 创建单个Fiber节点

创建单个Fiber节点的核心逻辑在`createFiberFromElement`函数中：

```javascript
function createFiberFromElement(element, mode, lanes) {
  let owner = null
  const type = element.type // 获取元素类型（如 'div', 自定义组件等）
  const key = element.key // 获取元素的 key
  const pendingProps = element.props // 获取元素的 props
  const fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes)
  return fiber
}
```

这个函数根据React元素的类型、key和props创建对应的Fiber节点。

## 2. 初始化提交

创建完Fiber树后，React需要将这些虚拟的Fiber节点渲染到实际的DOM中。这个过程称为"提交"(commit)。

### 2.1 提交前的准备

在进入提交阶段之前，React会做一些准备工作：

```javascript
function commitRoot(root) {
  const renderPriorityLevel = getCurrentPriorityLevel()
  runWithPriority(ImmediatePriority, commitRootImpl.bind(null, root, renderPriorityLevel))
  return null
}
```

这里，React将提交过程的优先级设置为最高(`ImmediatePriority`)，确保提交过程不会被打断。

### 2.2 提交阶段

提交阶段分为三个子阶段：Before mutation、Mutation和Layout。

```javascript
function commitRootImpl(root, renderPriorityLevel) {
  // Before mutation阶段
  commitBeforeMutationEffects(root, renderPriorityLevel)

  // Mutation阶段
  commitMutationEffects(root, renderPriorityLevel)

  // Layout阶段
  root.current = finishedWork
  commitLayoutEffects(root, lanes)

  requestPaint()
  return null
}
```

每个阶段都有特定的任务：

1. Before mutation阶段：处理DOM操作前的准备工作，如调用getSnapshotBeforeUpdate生命周期方法。
2. Mutation阶段：执行实际的DOM操作。
3. Layout阶段：处理DOM操作后的工作，如调用componentDidUpdate生命周期方法。

## 3. Fiber树的更新

当组件的状态发生变化时，React需要更新Fiber树并重新渲染。

### 3.1 调度更新

当我们调用`setState`或使用Hooks时，React会创建一个更新并将其加入更新队列：

```javascript
function enqueueUpdate(fiber, update) {
  const updateQueue = fiber.updateQueue
  const sharedQueue = updateQueue.shared
  const pending = sharedQueue.pending
  if (pending === null) {
    update.next = update
  } else {
    update.next = pending.next
    pending.next = update
  }
  sharedQueue.pending = update
}
```

### 3.2 开始工作循环

React使用工作循环来处理更新：

```javascript
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress)
  }
}
```

这个循环会不断地处理工作单元，直到完成所有工作或需要让出控制权。

### 3.3 对比和更新

在更新过程中，React会对比新旧Fiber树，找出需要更新的部分：

```javascript
function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes))
      // 处理其他类型...
    }
  }
  // 处理文本节点和其他情况...
}
```

这个过程会创建、更新或删除Fiber节点，最终形成一个新的Fiber树。
